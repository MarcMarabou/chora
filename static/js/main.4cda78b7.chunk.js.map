{"version":3,"sources":["Front End/patmos-mode.js","Front End/Editor.js","Front End/Simulator/DisplayButtons.js","Helpers/misc.js","Front End/Simulator/DisplayStorage.js","Front End/Simulator/DisplayCode.js","Front End/Simulator/Simulator.js","Front End/FrontEnd.js","Work Logic/Processor/ProcessorState.js","Helpers/typeStrings.js","Helpers/regStrings.js","Work Logic/Processor/CPU.js","Work Logic/Instructions/Binary Arithmetics/BinaryArithmetics.js","Work Logic/Instructions/Binary Arithmetics/compilers.js","Work Logic/Instructions/Binary Arithmetics/Add.js","Work Logic/Instructions/Binary Arithmetics/Nor.js","Work Logic/Instructions/Binary Arithmetics/ShiftAdd.js","Work Logic/Instructions/Binary Arithmetics/ShiftAdd2.js","Work Logic/Instructions/Binary Arithmetics/ShiftLeft.js","Work Logic/Instructions/Binary Arithmetics/ShiftRight.js","Work Logic/Instructions/Binary Arithmetics/ShiftRightArithmetic.js","Work Logic/Instructions/Binary Arithmetics/Sub.js","Work Logic/Instructions/Binary Arithmetics/Xor.js","Work Logic/Instructions/Binary Arithmetics/Or.js","Work Logic/Instructions/Binary Arithmetics/And.js","Work Logic/Instructions/Compare/Compare.js","Work Logic/Instructions/Compare/compilers.js","Work Logic/Instructions/Compare/Btest.js","Work Logic/Instructions/Compare/Cmpeq.js","Work Logic/Instructions/Compare/Cmple.js","Work Logic/Instructions/Compare/Cmplt.js","Work Logic/Instructions/Compare/Cmpneq.js","Work Logic/Instructions/Compare/Cmpule.js","Work Logic/Instructions/Compare/Cmpult.js","Work Logic/Instructions/Control Flow/ControlFlow.js","Work Logic/Instructions/Control Flow/compilers.js","Work Logic/Instructions/Control Flow/Br.js","Work Logic/Instructions/Control Flow/Brcf.js","Work Logic/Instructions/Control Flow/Brcfnd.js","Work Logic/Instructions/Control Flow/Brnd.js","Work Logic/Instructions/Control Flow/Call.js","Work Logic/Instructions/Control Flow/Callnd.js","Work Logic/Instructions/Control Flow/Ret.js","Work Logic/Instructions/Control Flow/Retnd.js","Work Logic/Instructions/Control Flow/Trap.js","Work Logic/Instructions/Control Flow/Xret.js","Work Logic/Instructions/Control Flow/Xretnd.js","Work Logic/Instructions/Load Typed/LoadTyped.js","Work Logic/Instructions/Load Typed/compilers.js","Work Logic/Instructions/Load Typed/Lws.js","Work Logic/Instructions/Load Typed/Lwl.js","Work Logic/Instructions/Load Typed/Lwc.js","Work Logic/Instructions/Load Typed/Lwm.js","Work Logic/Instructions/Load Typed/Lhs.js","Work Logic/Instructions/Load Typed/Lhl.js","Work Logic/Instructions/Load Typed/Lhc.js","Work Logic/Instructions/Load Typed/Lhm.js","Work Logic/Instructions/Load Typed/Lbs.js","Work Logic/Instructions/Load Typed/Lbl.js","Work Logic/Instructions/Load Typed/Lbc.js","Work Logic/Instructions/Load Typed/Lbm.js","Work Logic/Instructions/Load Typed/Lhus.js","Work Logic/Instructions/Load Typed/Lhul.js","Work Logic/Instructions/Load Typed/Lhuc.js","Work Logic/Instructions/Load Typed/Lhum.js","Work Logic/Instructions/Load Typed/Lbus.js","Work Logic/Instructions/Load Typed/Lbul.js","Work Logic/Instructions/Load Typed/Lbuc.js","Work Logic/Instructions/Load Typed/Lbum.js","Work Logic/Instructions/Multiply/Multiply.js","Work Logic/Instructions/Multiply/compilers.js","Work Logic/Instructions/Multiply/Mul.js","Work Logic/Instructions/Multiply/Mulu.js","Work Logic/Instructions/Predicate/Predicate.js","Work Logic/Instructions/Predicate/compilers.js","Work Logic/Instructions/Predicate/Pand.js","Work Logic/Instructions/Predicate/Pxor.js","Work Logic/Instructions/Predicate/Por.js","Work Logic/Instructions/Stack Control/StackControl.js","Work Logic/Instructions/Stack Control/compilers.js","Work Logic/Instructions/Stack Control/Sens.js","Work Logic/Instructions/Stack Control/Sfree.js","Work Logic/Instructions/Stack Control/Sres.js","Work Logic/Instructions/Stack Control/Sspill.js","Work Logic/Instructions/Store Typed/StoreTyped.js","Work Logic/Instructions/Store Typed/compilers.js","Work Logic/Instructions/Store Typed/Sbc.js","Work Logic/Instructions/Store Typed/Sbl.js","Work Logic/Instructions/Store Typed/Sbm.js","Work Logic/Instructions/Store Typed/Sbs.js","Work Logic/Instructions/Store Typed/Shc.js","Work Logic/Instructions/Store Typed/Shl.js","Work Logic/Instructions/Store Typed/Shm.js","Work Logic/Instructions/Store Typed/Shs.js","Work Logic/Instructions/Store Typed/Swc.js","Work Logic/Instructions/Store Typed/Swl.js","Work Logic/Instructions/Store Typed/Swm.js","Work Logic/Instructions/Store Typed/Sws.js","Work Logic/Instructions/Bcopy.js","Work Logic/Instructions/Mfs.js","Work Logic/Instructions/Mts.js","Helpers/regEx.js","Work Logic/Processor/Assembler.js","App.js","index.js"],"names":["CodeMirror","defineMode","config","parserConfig","getRegex","w","i","RegExp","join","instTypes","registers","keywords","normal","stream","state","ch","next","skipToEnd","test","eatWhile","startState","basecol","indentDepth","cur","token","eatSpace","style","word","current","Editor","props","code","readOnly","mode","lint","updateCode","bind","newCode","this","setState","editorUpdate","options","lineNumbers","value","onChange","autoFocus","Component","buttonCSS","forwardBtn","bundles","pc","runClick","stepClick","tooltipRun","tooltipStep","title","type","className","onClick","disabled","backwardsBtn","history","prevClick","resetClick","tooltipPrev","tooltipReset","length","DisplayButtons","dumpClick","parseNum","input","Number","parseReg","match","toUint32","n","intToHex","integer","toString","toUpperCase","padStart","intToHexStr","tableCSS","DisplayStorage","pagenumber","pageRows","maxPage","hex","incPage","decPage","jumpPage","updateDimensions","toggleHex","Math","floor","window","innerHeight","ceil","addEventListener","removeEventListener","prevState","des","parseInt","prompt","href","data-toggle","role","id","RenderRegTable","RenderMemoryTable","memory","rows","push","RegRow","key","scope","gm_temp","startAddr","endAddr","Object","assign","undefined","zeroRow","MemoryRowHex","MemoryRowDec","emptyRow","row","letter","idx","val","GenMachineRows","o","MachineRow","bundle","addr","color","instruction","binary","original","DisplayCode","Simulator","FrontEnd","click","toggle","errMes","error","numMap","alert","ProcessorState","reg","mem","cpu","r","m","c","prev","pop","pseudoTypes","binTypes","compTypes","loadTypes","storeTypes","mulTypes","stackTypes","predTypes","cfTypes","concat","pseudoMapping","getInstType","keys","instTypeStr","bin","includes","comp","load","store","mul","stack","pred","cf","regStr","allRegStr","sregMap","sl","sh","ss","st","srb","sro","sxb","sxo","CPU","pending_branch","reset","updateHistory","dualIssue","execute","handlePendingBranch","conflicts","ops","op","conflict","delay","inst","name","rewindOnce","start","end","performance","now","step","console","log","base_set","offset","is_data","data","base","instructions","setMem","size","int","setReadReg","getReg","getMemory","r0","p0","s0","BinaryArithmetics","func","rd","rs1","op2","isNaN","rs2","compile_reg","imm","compile_imm","long","compile_long","Error","Add","Nor","ShiftAdd","ShiftAdd2","ShiftLeft","ShiftRight","ShiftRightArithmetic","Sub","Xor","Or","And","Compare","pd","Btest","Cmpeq","Cmple","Cmplt","Cmpneq","Cmpule","Cmpult","ControlFLow","d","s1","s2","compile_ireg","compile_reg2","Br","ControlFlow","Brcf","Brcfnd","Brnd","Call","s7","s8","Callnd","Ret","Retnd","Trap","s9","s10","Xret","Xretnd","LoadTyped","ra","Lws","address","hh","hl","lh","ll","Lwl","Lwc","Lwm","Lhs","hi","lo","Lhl","Lhc","Lhm","Lbs","Lbl","Lbc","Lbm","Lhus","Lhul","Lhuc","Lhum","Lbus","Lbul","Lbuc","Lbum","Multiply","Mul","imul","Mulu","Predicate","ps1","ps2","neg1","neg2","replace","Pand","Pxor","Por","StackControl","rs","Sens","max","Sfree","Sres","Sspill","StoreTyped","Sbc","Sbl","Sbm","Sbs","Shc","Shl","Shm","Shs","Swc","Swl","Swm","Sws","Bcopy","ps","shift","Mfs","Mts","sd","regEx","getRegEx","getRegExError","Assembler","cleanInput","editor","lines","split","output","line","trim","insts","j","only_label","labels","parse","resolveOperands","compileBundle","checkErr","is_word","label","neg","toLowerCase","ptype","basic","_","p","slice","is_long_imm","allowedPipelineTwo","multi","t1","t2","op_lc","target","String","cInst","predicate","BinaryInst","CompareInst","ControlInst","LoadInst","MulInst","PredInst","StackInst","StoreInst","BcopyInst","App","clear","a","run","populate","forceUpdate","stepBtn","runBtn","resetBtn","prevBtn","dumpBtn","getMem","dump","Uint8Array","file","Blob","document","createElement","url","URL","createObjectURL","download","body","appendChild","setTimeout","removeChild","revokeObjectURL","overflowY","getPC","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.4cda78b7.chunk.js","sourcesContent":["import CodeMirror from \"codemirror\";\n\n((mod) => {\n\tmod(CodeMirror);\n}) ((CodeMirror) => {\n\t//\"use strict\";\n\n\tCodeMirror.defineMode(\"patmos\", (config, parserConfig) => {\n\t\tlet getRegex = (w, i) => {\n\t\t\treturn new RegExp(\"^(?:\" + w.join(\"|\") + \")$\", i);\n\t\t};\n\n\t\tlet instTypes = getRegex([\n\t\t\t/* Normal Instructions */\n\t\t\t// BA\n\t\t\t\"add\", \"addi\", \"addl\", \"sub\", \"subi\", \"subl\", \"xor\", \"xori\", \"xorl\", \"sl\", \"sli\", \"sll\",\n\t\t\t\"sr\", \"sri\", \"srl\", \"sra\", \"srai\", \"sral\", \"nor\", \"norl\", \"shadd\", \"shadd2\", \"or\", \"ori\", \"orl\",\n\t\t\t\"and\", \"andi\", \"andl\",\n\t\t\t// Compare\n\t\t\t\"btest\", \"btesti\", \"cmpeq\", \"cmpieq\", \"cmple\", \"cmpile\", \"cmplt\", \"cmpilt\", \n\t\t\t\"cmpneq\", \"cmpineq\", \"cmpule\", \"cmpiule\", \"cmpult\", \"cmpiult\",\n\t\t\t// Load\n\t\t\t\"lbc\", \"lbl\", \"lbm\", \"lbs\", \"lbuc\", \"lbul\", \"lbum\", \"lbus\", \"lhc\", \"lhl\", \n\t\t\t\"lhm\", \"lhs\", \"lhuc\", \"lhul\", \"lhum\", \"lhus\", \"lwc\", \"lwl\", \"lwm\", \"lws\",\n\t\t\t// Store\n\t\t\t\"sbc\", \"sbl\", \"sbm\", \"sbs\", \"shc\", \"shl\", \"shm\", \"shs\", \"swc\", \"swl\", \"swm\", \"sws\",\n\t\t\t// Multiply\n\t\t\t\"mul\", \"mulu\", \n\t\t\t// Stack Control\n\t\t\t\"sens\", \"sfree\", \"sres\", \"sspill\", \t\"sspillr\", \"sensr\",\n\t\t\t// Predicate\n\t\t\t\"pand\", \"por\", \"pxor\",\n\t\t\t// Move types\n\t\t\t\"mts\", \"mfs\",\n\t\t\t// Control Flow\n\t\t\t\"callnd\", \"call\", \"brnd\", \"br\", \"brcfnd\", \"brcf\", \"trap\",\n\t\t\t\"retnd\", \"ret\", \"xretnd\", \"xret\", \"callndr\", \"callr\", \n\t\t\t\"brndr\", \"brr\", \"brcfr\", \"brcfndr\",\n\t\t\t// Bit copy\n\t\t\t\"bcopy\",\n\n\t\t\t/* Pseudo Instructions */\n\t\t\t\"mov\", \"clr\", \"neg\", \"not\", \"li\", \"nop\", \"isodd\", \"pmov\", \"pnot\", \"pset\", \"pclr\",\n\t\t], \"i\");\n\n\t\tlet registers = getRegex([\n\t\t// General-purpose\n\t\t\t\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \n\t\t\t\"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \n\t\t\t\"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\n\t\t\t// Predicate\n\t\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n\t\t\t// Special-purpose\n\t\t\t\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \n\t\t\t\"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\",\n\t\t\t// Special names\n\t\t\t\"sl\", \"sh\", \"ss\", \"st\", \"srb\", \"sro\", \"sxb\", \"sxo\",\n\t\t], \"\");\n\n\t\tlet keywords = getRegex([\".word\"], \"i\");\n\n\t\tlet normal = (stream, state) => {\n\t\t\tlet ch = stream.next();\n\n\t\t\t// Eat entire comment\n\t\t\tif (ch === \"#\") {\n\t\t\t\tstream.skipToEnd();\n\t\t\t\treturn \"comment\";\n\t\t\t}\n\t\t\n\t\t\t// Eat all digits of number\n\t\t\tif (/\\d/.test(ch)) {\n\t\t\t\tstream.eatWhile(/[\\w.%]/);\n\t\t\t\treturn \"number\";\n\t\t\t}\n\n\t\t\t// Eat all characters of register / keyword\n\t\t\tif (/[.\\w_]/.test(ch)) {\n\t\t\t\tstream.eatWhile(/[\\w\\\\\\-_.]/);\n\t\t\t\treturn \"variable\";\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\treturn {\n\t\t\tstartState: (basecol) => {\n\t\t\t\treturn { basecol: basecol || 0, indentDepth: 0, cur: normal };\n\t\t\t},\n\n\t\t\ttoken: (stream, state) => {\n\t\t\t\tif (stream.eatSpace()) return null;\n\t\t\t\tlet style = state.cur(stream, state);\n\t\t\t\tlet word = stream.current();\n\n\t\t\t\t// Use different colors for types, registers and keywords\n\t\t\t\tif (style === \"variable\") {\n\t\t\t\t\tif (keywords.test(word)) style = \"keyword\";\n\t\t\t\t\telse if (instTypes.test(word)) style = \"builtin\";\n\t\t\t\t\telse if (registers.test(word)) style = \"variable-2\";\n\t\t\t\t}\n\t\t\t\treturn style;\n\t\t\t}\n\t\t};\n\t});\n\n\t// inspiration from codemirror.net/addon/lint/javascript-lint.js \n\t// let validator = (text, options) => {\n\t// \tif(!window.JSHINT) {\n\t// \t\tif (window.console) {\n\t// \t\t\twindow.console.error(\"Error: window. not defined, CodeMirror Patmos-mode linting cannot run.\");\n\t// \t\t}\n\t// \t\treturn [];\n\t// \t}\n\t// \tif (!options.indent) // JSHint error.character actually is a column index, this fixes underlining on lines using tabs for indentation\n\t// \t\toptions.indent = 1; // JSHint default value is 4\n\t// \tJSHINT(text, options, options.globals);\n\t// \tlet errors = JSHINT.data().errors, result = [];\n\t// \tif (errors) parseErrors(errors, result);\n\t// \treturn result;\n\t// };\n\n\t// let parseErrors = (errors, output) => {\n\t// \tfor ( let i = 0; i < errors.length; i++) {\n\t// \t\tlet error = errors[i];\n\t// \t\tif (error) {\n\t// \t\t\tif (error.line <= 0) {\n\t// \t\t\t\tif (window.console)\n\t// \t\t\t\t\twindow.console.warn(\"Cannot display JSHint error (invalid line \" + error.line + \")\", error);\n\t// \t\t\t\tcontinue;\n\t// \t\t\t}\n\n\t// \t\t\tlet start = error.character - 1, end = start + 1;\n\t\t\t\t\n\t// \t\t\tif (error.evidence) {\n\t// \t\t\t\tlet index = error.evidence.substring(start).search(/.\\b/);\n\t// \t\t\t\tif (index > -1) end += index;\n\t// \t\t\t}\n\n\t// \t\t\t// Convert to format expected by validation service\n\t// \t\t\toutput.push({\n\t// \t\t\t\tmessage: error.reason,\n\t// \t\t\t\tseverity: error.code ? (error.code.startsWith('W') ? \"warning\" : \"error\") : \"error\",\n\t// \t\t\t\tfrom: CodeMirror.Pos(error.line - 1, start),\n\t// \t\t\t\tto: CodeMirror.Pos(error.line - 1, end)\n\t// \t\t\t});\n\t// \t\t}\n\t// \t}\n\t// };\n\n\t// CodeMirror.registerHelper(\"lint\", \"patmos\", validator);\n});\n  ","import React, { Component } from \"react\";\nimport CodeMirror from \"react-codemirror\";\nimport PropTypes from \"prop-types\";\nimport \"../../node_modules/codemirror/lib/codemirror.css\";\nimport \"./patmos-mode\";\n//import \"../../node_modules/codemirror/mode/patmos/patmos\";\n\nclass Editor extends Component{\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tcode: \"\",\n\t\t\treadOnly: false,\n\t\t\tmode: \"patmos\",\n\t\t\tlint: true,\n\t\t};\n\n\t\tthis.updateCode = this.updateCode.bind(this);\n\t}\n\n\tupdateCode (newCode) {\n\t\tthis.setState({\n\t\t\tcode: newCode,\n\t\t});\n\t\tthis.props.editorUpdate(newCode);\n\t}\n\n\trender() {\n\t\tlet options = {\n\t\t\tmode: this.state.mode,\n\t\t\tlineNumbers: true,\n\t\t};\n\t\treturn(\n\t\t\t<div><CodeMirror value={this.state.code} onChange={this.updateCode} options={options} autoFocus={true}/></div>\n\t\t);\n\t}\n}\n\nEditor.propTypes = {\n\teditorUpdate : PropTypes.func\n};\n\nexport default Editor;\n","import React, { Fragment } from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"../../CSS/Buttons.css\";\n\nconst buttonCSS = [\n\t\"btn button run col-2\", \n\t\"btn button step col-2\", \n\t\"btn button prev col-2\",\n\t\"btn button reset col-2\",\n\t\"btn button dump col-2\",\n];\n\n/**\n * DisplayButtons: Handles display of buttons and returns clicks of buttons.\n * @param {object} \tprops.bundles\t\t- Object consisting of all instruction bundles from editor\n * @param {number}\tprops.pc\t\t\t- Current CPU program counter\n * @param {func}\tprops.runClick\t\t- Button run clicked handler\n * @param {func}\tprops.stepClick\t\t- Button step clicked handler\n * @param {func}\tprops.prevClick\t\t- Button prev clicked handler\n * @param {func}\tprops.resetClick\t- Button reset clicked handler\n */\nconst DisplayButtons = (props) => {\n\treturn (\n\t\t<div className=\"button-container\">\n\t\t\t{forwardBtn(props.bundles, props.pc, props.runClick, props.stepClick)}\n\t\t\t{backwardsBtn(props.history, props.prevClick, props.resetClick)}\n\t\t\t<button type =\"button\" className={buttonCSS[4]} onClick = {props.dumpClick}>Dump</button>\n\t\t</div>  \n\t);\n};\n\n/**\n * fowardBtn: Handles the two buttons \"Run\" and \"Step\".\n * Disables the buttons if no instructions left in queue.\n * @param {Object} \tbundles \t- Object consisting of all instruction bundles from editor\n * @param {number} \tpc \t\t\t- Current CPU program counter\n * @param {func} \trunClick \t- Button run clicked handler\n * @param {func} \tstepClick \t- Button step clicked handler\n */\nconst forwardBtn = (bundles, pc, runClick, stepClick) => {\n\tlet tooltipRun = \"Run all remaining instructions in queue\";\n\tlet tooltipStep = \"Step next instruction in queue\";\n\n\tif (!bundles[pc]) {\n\t\ttooltipRun = \"No instructions to run\";\n\t\ttooltipStep = \"No instructions to step\";\n\t\treturn (\n\t\t\t<Fragment>\n\t\t\t\t<button title={tooltipRun} type=\"button\" className={buttonCSS[0]} disabled>Run</button>\n\t\t\t\t<button title={tooltipStep} type=\"button\" className={buttonCSS[1]} disabled>Step</button>\n\t\t\t</Fragment>\n\t\t);\n\t}\n\treturn (\n\t\t<Fragment>\n\t\t\t<button title={tooltipRun} type=\"button\" className={buttonCSS[0]} onClick={runClick}  >Run</button>\n\t\t\t<button title={tooltipStep} type=\"button\" className={buttonCSS[1]} onClick={stepClick} >Step</button>\n\t\t</Fragment>\n\t);\n};\n\n/**\n * backwardsBtn: Handles the two buttons \"Prev\" and \"Reset\".\n * Disables the buttons if no instructions has been executed yet.\n * @param {number} \tpc \t\t\t- Current CPU program counter\n * @param {func} \tprevClick \t- Button prev clicked handler\n * @param {func} \tresetClick \t- Button reset clicked handler\n */\nconst backwardsBtn = (history, prevClick, resetClick) => {\n\tlet tooltipPrev = \"Steps one instruction back (decrement program count)\";\n\tlet tooltipReset = \"Reset registers & memory and jump to first instruction\";\n\n\tif (history.length === 0) {\n\t\ttooltipReset = \"No instructions run yet\";\n\t\ttooltipPrev = \"No instructions run yet\";\n\t\treturn (\n\t\t\t<Fragment>\n\t\t\t\t<button title={tooltipPrev} type=\"button\" className={buttonCSS[2]} disabled>Prev</button>\n\t\t\t\t<button title={tooltipReset} type=\"button\" className={buttonCSS[3]} disabled>Reset</button>\n\t\t\t</Fragment>\n\t\t);\n\t}\n\treturn (\n\t\t<Fragment>\n\t\t\t<button title={tooltipPrev} type=\"button\" className={buttonCSS[2]} onClick={prevClick}  >Prev</button>\n\t\t\t<button title={tooltipReset} type=\"button\" className={buttonCSS[3]} onClick={resetClick}>Reset</button>\n\t\t</Fragment>\n\t);\n};\n\nDisplayButtons.propTypes = {\n\thistory     : PropTypes.array,\n\tbundles \t: PropTypes.object,\n\tpc \t\t\t: PropTypes.number,\n\trunClick \t: PropTypes.func,\n\tstepClick\t: PropTypes.func,\n\tprevClick \t: PropTypes.func,\n\tresetClick \t: PropTypes.func,\n\tdumpClick\t: PropTypes.func,\n};\n\n\nexport default DisplayButtons;\n","export const parseNum = (input) => typeof input == \"number\" ? input : Number(input);\nexport const parseReg = (input) => typeof input == \"number\" ? input : Number(input.match(/\\d+/i)[0]);\nexport const toUint32 = (n) => n >>> 0;\nexport const toInt32 = (n) => n | 0;\nexport const intToHex = (integer, length) => {\n\tinteger = Number(integer);\n\n\tif (integer < 0) {\n\t\tinteger = 0xFFFFFFFF + integer + 1;\n\t}\n\treturn integer.toString(16).toUpperCase().padStart(length, \"0\");\n};\nexport const intToHexStr = (integer, length) => {\n\treturn `0x${intToHex(integer, length)}`;\n};\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { intToHex, intToHexStr } from \"../../Helpers/misc\";\nimport \"../../CSS/Simulator.css\";\nimport \"../../CSS/Buttons.css\";\nimport \"../../CSS/App.css\";\n\nconst tableCSS = \"table table-hover table-sm col-12\";\nconst maxSize = 0x00200000;\n\nclass DisplayStorage extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tpagenumber\t: 1,\n\t\t\tpageRows \t: 0,\n\t\t\tmaxPage \t: 0,\n\t\t\thex\t\t\t: false,\n\t\t};\n\n\t\tthis.incPage = this.incPage.bind(this);\n\t\tthis.decPage = this.decPage.bind(this);\n\t\tthis.jumpPage = this.jumpPage.bind(this);\n\t\tthis.updateDimensions = this.updateDimensions.bind(this);\n\t\tthis.toggleHex = this.toggleHex.bind(this);\n\t}\n\n\tupdateDimensions() {\n\t\tlet pageRows = Math.floor((window.innerHeight - 220) / 35); // row 34.6\n\t\tthis.setState({ \n\t\t\tpageRows\t: pageRows,\n\t\t\tmaxPage\t\t: Math.ceil(maxSize / (pageRows*4)),\n\t\t});\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.updateDimensions();\n\t\twindow.addEventListener(\"resize\", this.updateDimensions);\n\t}\n\t\n\tcomponentWillUnmount() {\n\t\twindow.removeEventListener(\"resize\", this.updateDimensions);\n\t}\n\n\tincPage() {\n\t\tif ((this.state.pagenumber+1) <= this.state.maxPage)\n\t\t\tthis.setState((prevState) => ({ pagenumber: prevState.pagenumber + 1 }));\n\t}\n\n\tdecPage() {\n\t\tif (this.state.pagenumber > 1)\n\t\t\tthis.setState((prevState) => ({ pagenumber: prevState.pagenumber - 1 }));\n\t}\n\n\tjumpPage() {\n\t\tlet des = parseInt(Number(prompt(\"What address do you want to jump to? Both hexadecimal and decimal numbers accepted.\")), 10) / (this.state.pageRows*4);\n\t\tif (des <= this.state.maxPage) \n\t\t\tthis.setState(() => ({ pagenumber: Math.floor(des)+1 }));\n\t}\n\n\ttoggleHex() {\n\t\tthis.setState((prevState) => ({ hex : prevState.hex ? false : true }));\n\t}\n\n\trender() {\n\t\treturn(\n\t\t\t<div>\n\t\t\t\t<ul className =\"nav nav-tabs justify-content-center\">\n\t\t\t\t\t<li className=\"nav-item\">\n\t\t\t\t\t\t<a href=\"#registers\" className=\"nav-link active\" data-toggle=\"tab\" role=\"tab\">Registers</a>\n\t\t\t\t\t</li>\n\t\t\t\t\t<li className=\"nav-item\">\n\t\t\t\t\t\t<a href=\"#gm\" className=\"nav-link\" data-toggle=\"tab\" role=\"tab\">Memory</a>\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\n\t\t\t\t<div className=\"tab-content\">\n\t\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane active table-scrolling\" id=\"registers\">\n\t\t\t\t\t\t{RenderRegTable(this.props.registers)}\n\t\t\t\t\t</div>\n\t\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane\" id=\"gm\">\n\t\t\t\t\t\t{RenderMemoryTable(this.props.memory, this.state.pagenumber, this.state.pageRows, this.state.hex)}\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.decPage}>Prev</button>\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.incPage}>Next</button>\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.jumpPage}>Jump</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-12\" onClick={this.toggleHex}>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis.state.hex ? \"Change to decimal\" : \"Change to hexadecimal\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\t\n\t\t);\n\t}\n}\n\n/**\n * RenderRegTable: Returns the register table with columns Register, Decimal, Hexadecimal\n * @param {Object} registers - Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\n */\nconst RenderRegTable = (registers) => {\n\tvar rows = [];\n\n\t// Generate rows: 32 r-, 16 s-, and 8 p-rows.\n\tfor (let i = 0; i < 32; i++) {\n\t\trows.push(RegRow(\"r\", i, registers));\n\t}\n\tfor (let i = 0; i < 16; i++) {\n\t\trows.push(RegRow(\"s\", i, registers));\n\t}\n\tfor (let i = 0; i < 8; i++) {\n\t\trows.push(RegRow(\"p\", i, registers));\n\t}\n\n\t// This row overflows when scrolled all the way down. \n\trows.push(\n\t\t<tr key={\"bottom\"}>\n\t\t\t<th>---</th>\n\t\t\t<td>---</td>\n\t\t\t<td>---</td>\n\t\t</tr>\n\t);\n\n\t// Return table\n\treturn (\n\t\t<table className={tableCSS}>\n\t\t\t<thead className=\"header-stick\">\n\t\t\t\t<tr className=\"header-stick\">\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Register</th>\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Decimal</th>\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Hexadecimal</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{rows}\t\n\t\t\t</tbody>\n\t\t</table>\n\t);\n};\n\n/**\n * RenderMemoryTable: Returns the memory table with columns Address, +0, +1, +2, +3\n * @param {Object} props.memory\t\t- Object containing the memory of the program. \n */\nconst RenderMemoryTable = (memory, pagenumber, pageRows, hex) => {\n\tlet gm_temp, rows = [];\n\n\tlet startAddr = (pagenumber-1)*pageRows*4;\n\tlet endAddr = pagenumber*pageRows*4;\n\n\t// We don't want to display these fields:\n\tgm_temp = Object.assign({}, memory);\n\tdelete gm_temp[\"BASE_ADDR\"];\n\tdelete gm_temp[\"MAX_SIZE\"];\n\tdelete gm_temp[\"TEXT_END\"];\n\n\tfor (let i = startAddr; i < endAddr; i+= 4) {\n\t\tif (i <= maxSize) {\n\t\t\tif (gm_temp[i] === undefined && gm_temp[i+1] === undefined && gm_temp[i+2] === undefined && gm_temp[i+3] === undefined) {\n\t\t\t\trows.push(zeroRow(i, hex));\n\t\t\t} else {\n\t\t\t\thex ? rows.push(MemoryRowHex(gm_temp, i)) : rows.push(MemoryRowDec(gm_temp, i));\n\t\t\t}\n\t\t} else {\n\t\t\trows.push(emptyRow(i));\n\t\t}\n\t}\n\n\t// Return table\n\treturn (\n\t\t<table className={tableCSS}>\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th scope=\"col\">Address</th>\n\t\t\t\t\t<th scope=\"col\">+0</th>\n\t\t\t\t\t<th scope=\"col\">+1</th>\n\t\t\t\t\t<th scope=\"col\">+2</th>\n\t\t\t\t\t<th scope=\"col\">+3</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{rows}\n\t\t\t</tbody>\n\t\t</table>\n\t);\n};\n\nconst emptyRow = (key) => {\n\treturn(\n\t\t<tr key={key}>\n\t\t\t<td>----------</td>\n\t\t\t<td>---</td>\n\t\t\t<td>---</td>\n\t\t\t<td>---</td>\n\t\t\t<td>---</td>\n\t\t</tr>\n\t);\n};\n\nconst zeroRow = (key, hex) => {\n\treturn(\n\t\t<tr key={key}>\n\t\t\t<td>{intToHexStr(key, 8)}</td>\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\n\t\t</tr>\n\t);\n};\n\n/**\n * MemoryRow: Returns one row of the memory table.\n * @param {Object} memory - Object containing the global memory of the program. \n */\nconst MemoryRowDec = (memory, key) => {\n\tlet row = [\n\t\tmemory[`${key}`] === undefined ? 0 : memory[`${key}`], \n\t\tmemory[`${key+1}`] === undefined ? 0 : memory[`${key+1}`], \n\t\tmemory[`${key+2}`] === undefined ? 0 : memory[`${key+2}`], \n\t\tmemory[`${key+3}`] === undefined ? 0 : memory[`${key+3}`], \n\t];\n\n\treturn(\n\t\t<tr key={key}>\n\t\t\t<td>{intToHexStr(key, 8)}</td>\n\t\t\t<td>{row[0]}</td>\n\t\t\t<td>{row[1]}</td>\n\t\t\t<td>{row[2]}</td>\n\t\t\t<td>{row[3]}</td>\n\t\t</tr>\n\t);\n};\n\n/**\n * MemoryRow: Returns one row of the memory table in hexadecimal.\n * @param {Object} memory - Object containing the global memory of the program. \n */\nconst MemoryRowHex = (memory, key) => {\n\tlet row = [\n\t\tmemory[`${key}`] === undefined ? 0 : memory[`${key}`], \n\t\tmemory[`${key+1}`] === undefined ? 0 : memory[`${key+1}`], \n\t\tmemory[`${key+2}`] === undefined ? 0 : memory[`${key+2}`], \n\t\tmemory[`${key+3}`] === undefined ? 0 : memory[`${key+3}`], \n\t];\n\n\treturn(\n\t\t<tr key={key}>\n\t\t\t<td>{intToHexStr(key, 8)}</td>\n\t\t\t<td>{intToHex(row[0], 2)}</td>\n\t\t\t<td>{intToHex(row[1], 2)}</td>\n\t\t\t<td>{intToHex(row[2], 2)}</td>\n\t\t\t<td>{intToHex(row[3], 2)}</td>\n\t\t</tr>\n\t);\n};\n\n/**\n * RegRow: Returns one row of the register table.\n * @param {string} letter \t\t- Either r, p or s\n * @param {number} idx \t\t\t- Current idx of the register\n * @param {Object} registers \t- Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\n */\nconst RegRow = (letter, idx, registers) => {\n\tlet val = registers[`${letter}${idx}`];\n\n\treturn(\n\t\t<tr key={`${letter}${idx}`}>\n\t\t\t<td>{letter}{idx}</td>\n\t\t\t<td>{val}</td>\n\t\t\t<td>{intToHexStr(val, 8)}</td>\n\t\t</tr>\n\t);\n};\n\nDisplayStorage.propTypes = {\n\tregisters \t: PropTypes.object,\n\tmemory \t\t: PropTypes.object,\n};\n\nexport default DisplayStorage;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { intToHexStr } from \"../../Helpers/misc\";\nimport \"../../CSS/Simulator.css\";\n\n/**\n * DisplayCode: Displays all the instructions in the instruction queue as machine, basic and original code.\n * @param {number}\tprops.pc\t\t- Current CPU program counter\n * @param {Object}\tprops.bundles\t- Object consisting of all instruction bundles from editor\n */\nconst DisplayCode = (props) => {\n\treturn (\n\t\t<div className=\"code-container\">\n\t\t\t<table className=\"table table-hover table-sm\" id=\"displaycode\">\n\t\t\t\t<thead>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th scope=\"col\">Machine Code</th>\n\t\t\t\t\t\t<th scope=\"col\">Basic Code</th>\n\t\t\t\t\t\t<th scope=\"col\">Original Code</th>\n\t\t\t\t\t</tr>\n\t\t\t\t</thead>\n\t\t\t\t<tbody>\n\t\t\t\t\t{GenMachineRows(props.pc, props.bundles)}\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t</div>\n\t);\n};\n\n/**\n * GenMachineRows: Generates all code table rows. \n * Done by calling MachineRow on each bundle in bundles. \n * @param {Object}\tprops.bundles\t- Object consisting of all instruction bundles from editor\n * @param {number}\tpc\t\t\t\t- Current CPU program counter\n */\nconst GenMachineRows = (pc, bundles) => {\n\tlet rows = [];\n\tfor (let o in bundles){\n\t\trows.push(MachineRow(bundles[o], pc, o));\n\t}\n\treturn rows;\n};\n\n/**\n * MachineRow: Generates one row of the table: Binary | Basic Code | Original code\n * Highlights row if current row is the same as program counter (i = pc).\n * @param {Object}\tbundles\t- Object consisting of all instruction bundles from editor\n * @param {number}\tpc\t\t- Current CPU program counter\n * @param {number} \taddr\t- Current bundle address \n */\nconst MachineRow = (bundle, pc, addr) => {\n\tlet idx = 0;\n\tlet color = pc === Number(addr) ? \"current-inst\" : \"\";\n\tlet rows = [];\n\t\n\tfor(let i of bundle){\n\t\trows.push(\n\t\t\t<tr key={idx} className={color} >\n\t\t\t\t<td>{intToHexStr(i.instruction.binary[0], 8)}</td>\n\t\t\t\t<td>{i.instruction.toString()}</td>\n\t\t\t\t<td>{i.original}</td>\n\t\t\t</tr>\n\t\t);\n\t\tidx++;\n\t}\n\treturn rows;\n};\n\nDisplayCode.propTypes = {\n\tpc \t\t\t\t: PropTypes.number,\n\tbundles\t\t\t: PropTypes.object,\n};\n\nexport default DisplayCode;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport DisplayButtons from \"./DisplayButtons\";\nimport DisplayStorage from \"./DisplayStorage\";\nimport DisplayCode from \"./DisplayCode\";\nimport \"../../CSS/Simulator.css\";\n\n/**\n * Simulator: Handles all the displaying under the \"Simulator\" tab.\n * @param {number}\tprops.pc\t\t\t- Current CPU program counter\n * @param {func}\tprops.runClick\t\t- Button run clicked handler\n * @param {func}\tprops.stepClick\t\t- Button step clicked handler\n * @param {func}\tprops.prevClick\t\t- Button prev clicked handler\n * @param {func}\tprops.resetClick\t- Button reset clicked handler\n * @param {Object}\tprops.bundles \t\t- Object containing all instruction bundles from editor\n * @param {Object} \tprops.registers \t- Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\n * @param {Object} \tprops.memory\t\t- Object containing the global memory of the program\n * @param {string} \tprops.consoleOutput - The output string to console\n */\nconst Simulator = (props) => {\n\treturn(\n\t\t<div className=\"sim\">\n\t\t\t<div className=\"col-8 col-xl-9 sim-child\">\n\t\t\t\t<DisplayButtons \n\t\t\t\t\thistory = {props.history}\n\t\t\t\t\tstepClick = {props.stepClick} \n\t\t\t\t\trunClick = {props.runClick}\n\t\t\t\t\tprevClick = {props.prevClick}\n\t\t\t\t\tresetClick = {props.resetClick}\n\t\t\t\t\tdumpClick = {props.dumpClick}\n\t\t\t\t\tpc = {props.pc}\n\t\t\t\t\tbundles = {props.bundles}\n\t\t\t\t/>\n\t\t\t\t<DisplayCode\n\t\t\t\t\tpc = {props.pc}\n\t\t\t\t\tbundles = {props.bundles}\n\t\t\t\t/>\n\t\t\t</div>\n\n\t\t\t<div className=\"col-4 col-xl-3 reg-container sim-child\">\n\t\t\t\t<DisplayStorage\n\t\t\t\t\tregisters = {props.registers}\n\t\t\t\t\tmemory = {props.memory}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nSimulator.propTypes = {\n\thistory         : PropTypes.array,\n\tpc \t\t\t\t: PropTypes.number,\n\trunClick \t\t: PropTypes.func,\n\tstepClick\t\t: PropTypes.func,\n\tprevClick \t\t: PropTypes.func,\n\tresetClick \t\t: PropTypes.func,\n\tdumpClick\t\t: PropTypes.func,\n\tbundles\t\t\t: PropTypes.object,\n\tregisters \t\t: PropTypes.object,\n\tmemory \t\t\t: PropTypes.object,\n};\n\nexport default Simulator;\n","import React, { Fragment } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Editor from \"./Editor\";\nimport Simulator from \"./Simulator/Simulator\";\n\n/**\n * FrontEnd: Handles the entire front end of Chora. Splits into two tabs: Editor and Simulator.\n */\nconst FrontEnd = (props) => {\n\tlet click, toggle = \"tab\", errMes = \"\";\n\n\t// fix it so it displays correct line number instead of\n\tif (props.error.length) { \n\t\tfor (let i in props.error) errMes += props.error[i] === \"fine\" ? \"\" : `L${props.numMap[i]}: ` + props.error[i] + \"\\n\";\n\t\tclick = () => { alert(errMes); };\n\t\ttoggle = \"\";\n\t}\n\n\treturn (\n\t\t<Fragment>\n\t\t\t<ul className =\"nav nav-tabs justify-content-center\">\n\t\t\t\t<li className=\"nav-item\">\n\t\t\t\t\t<a href=\"#editor\" className=\"nav-link active\" data-toggle=\"tab\" role=\"tab\">Editor</a>\n\t\t\t\t</li>\n\t\t\t\t<li className=\"nav-item \">\n\t\t\t\t\t<a href=\"#simulator\" className=\"nav-link\" onClick={click} data-toggle={toggle} role=\"tab\">Simulator</a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\n\t\t\t<div className=\"tab-content no-scroll\">\n\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane active\" id=\"editor\">\n\t\t\t\t\t<Editor\n\t\t\t\t\t\teditorUpdate = {props.editorUpdate}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane\" id=\"simulator\">\n\t\t\t\t\t<Simulator\n\t\t\t\t\t\thistory = {props.history}\n\t\t\t\t\t\tmemory = {props.memory}\n\t\t\t\t\t\tstepClick = {props.stepClick}\n\t\t\t\t\t\trunClick = {props.runClick}\n\t\t\t\t\t\tprevClick = {props.prevClick}\n\t\t\t\t\t\tresetClick = {props.resetClick}\n\t\t\t\t\t\tdumpClick = {props.dumpClick}\n\t\t\t\t\t\tregisters = {props.registers}\n\t\t\t\t\t\tpc = {props.pc}\n\t\t\t\t\t\tbundles = {props.bundles}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</Fragment>\n\t);\n};\n\nFrontEnd.propTypes = {\n\thistory         : PropTypes.array,\n\teditorUpdate \t: PropTypes.func,\n\tpc \t\t\t\t: PropTypes.number,\n\trunClick \t\t: PropTypes.func,\n\tstepClick\t\t: PropTypes.func,\n\tprevClick \t\t: PropTypes.func,\n\tresetClick \t\t: PropTypes.func,\n\tdumpClick\t\t: PropTypes.func,\n\tbundles\t\t\t: PropTypes.object,\n\tregisters \t\t: PropTypes.object,\n\tmemory \t\t\t: PropTypes.object,\n\terror\t\t\t: PropTypes.arrayOf(String),\n\tnumMap\t\t\t: PropTypes.array,\n};\n\nexport default FrontEnd;\n","class ProcessorState {\n\tconstructor() {\n\t\tthis.history = [];\n\t\tthis.reg = {\n\t\t\t// General-purpose registers\n\t\t\t\"r0\" : 0,\n\t\t\t\"r1\" : 0, \"r2\" : 0, \"r3\" : 0, \"r4\" : 0, \"r5\" : 0,\n\t\t\t\"r6\" : 0, \"r7\" : 0, \"r8\" : 0, \"r9\" : 0, \"r10\" : 0, \n\t\t\t\"r11\" : 0, \"r12\" : 0, \"r13\" : 0, \"r14\" : 0, \"r15\" : 0,\n\t\t\t\"r16\" : 0, \"r17\" : 0, \"r18\" : 0, \"r19\" : 0, \"r20\" : 0, \n\t\t\t\"r21\" : 0, \"r22\" : 0, \"r23\" : 0, \"r24\" : 0, \"r25\" : 0,\n\t\t\t\"r26\" : 0, \"r27\" : 0, \"r28\" : 0, \"r29\" : 0, \"r30\" : 0, \n\t\t\t\"r31\" : 0,\n\t\t\t// Special-purpose registers\n\t\t\t\"s0\" : 1, \"s1\" : 0, \"s2\" : 0, \"s3\" : 0, \"s4\" : 0, \"s5\" : 0,\n\t\t\t\"s6\" : 0, \"s7\" : 0, \"s8\" : 0, \"s9\" : 0, \"s10\" : 0,\n\t\t\t\"s11\" : 0, \"s12\" : 0, \"s13\" : 0, \"s14\" : 0, \"s15\" : 0,\n\t\t\t// Predicate registers\n\t\t\t\"p0\": 1, \"p1\": 0, \"p2\" : 0, \"p3\" : 0, \"p4\" : 0, \"p5\" : 0,\n\t\t\t\"p6\" : 0, \"p7\" : 0\n\t\t};\n\t\tthis.mem = {\n\t\t\t\"TEXT_END\" \t: 0,\n\t\t\t\"BASE_ADDR\"\t: 0x0,\n\t\t\t\"MAX_SIZE\"\t: 0x00200000 // 2MiB\n\t\t};\n\t\tthis.cpu = {\n\t\t\t\"base\": 0,\n\t\t\t\"pc\": 0\n\t\t};\n\t}\n\t\n\treset() {\n\t\tthis.history = [];\n\t\tthis.mem = {\n\t\t\t\"TEXT_END\" \t: 0,\n\t\t\t\"BASE_ADDR\"\t: 0x0,\n\t\t\t\"MAX_SIZE\"\t: 0x00200000 // 2MiB\n\t\t};\n\t\tthis.reg = {\n\t\t\t// General-purpose registers\n\t\t\t\"r0\" : 0,\n\t\t\t\"r1\" : 0, \"r2\" : 0, \"r3\" : 0, \"r4\" : 0, \"r5\" : 0,\n\t\t\t\"r6\" : 0, \"r7\" : 0, \"r8\" : 0, \"r9\" : 0, \"r10\" : 0, \n\t\t\t\"r11\" : 0, \"r12\" : 0, \"r13\" : 0, \"r14\" : 0, \"r15\" : 0,\n\t\t\t\"r16\" : 0, \"r17\" : 0, \"r18\" : 0, \"r19\" : 0, \"r20\" : 0, \n\t\t\t\"r21\" : 0, \"r22\" : 0, \"r23\" : 0, \"r24\" : 0, \"r25\" : 0,\n\t\t\t\"r26\" : 0, \"r27\" : 0, \"r28\" : 0, \"r29\" : 0, \"r30\" : 0, \n\t\t\t\"r31\" : 0,\n\t\t\t// Special-purpose registers\n\t\t\t\"s0\" : 1, \"s1\" : 0, \"s2\" : 0, \"s3\" : 0, \"s4\" : 0, \"s5\" : 0,\n\t\t\t\"s6\" : 0, \"s7\" : 0, \"s8\" : 0, \"s9\" : 0, \"s10\" : 0,\n\t\t\t\"s11\" : 0, \"s12\" : 0, \"s13\" : 0, \"s14\" : 0, \"s15\" : 0,\n\t\t\t// Predicate registers\n\t\t\t\"p0\": 1, \"p1\": 0, \"p2\" : 0, \"p3\" : 0, \"p4\" : 0, \"p5\" : 0,\n\t\t\t\"p6\" : 0, \"p7\" : 0\n\t\t};\n\t\tthis.cpu = {\n\t\t\t\"base\": 0,\n\t\t\t\"pc\": 0\n\t\t};\n\t}\n\t\n\tgetMemory() {\n\t\treturn this.mem;\n\t}\n\n\tgetReg() {\n\t\treturn this.reg; \n\t}\n\n\tupdateHistory(){\n\t\tlet r, m, c;\n\t\tr = Object.assign({}, this.reg);\n\t\tm = Object.assign({}, this.mem);\n\t\tc = Object.assign({}, this.cpu);\n\t\tthis.history.push({reg: r, mem: m, cpu: c});\n\t}\n\t\n\trewindOnce(){\n\t\tlet prev = this.history.pop();\n\t\tif(!prev)\n\t\t\treturn false;\n\t\tthis.reg = prev.reg;\n\t\tthis.mem = prev.mem;\n\t\tthis.cpu = prev.cpu;\n\t\treturn true;\n\t}\n}\n\nexport default ProcessorState;\n","const pseudoTypes = [\n\t\"mov\", \"clr\", \"neg\", \"not\", \"li\", \"nop\", \"isodd\", \"pmov\", \"pnot\", \"pset\", \"pclr\"\n];\nconst binTypes = [\n\t\"add\", \"addi\", \"addl\", \"sub\", \"subi\", \"subl\", \"xor\", \"xori\", \"xorl\", \"sl\", \"sli\", \"sll\",\n\t\"sr\", \"sri\", \"srl\", \"sra\", \"srai\", \"sral\", \"nor\", \"norl\", \"shadd\", \"shadd2\", \"or\", \"ori\", \"orl\",\n\t\"and\", \"andi\", \"andl\",\n];\nconst compTypes = [\n\t\"btest\", \"btesti\", \"cmpeq\", \"cmpieq\", \"cmple\", \"cmpile\", \"cmplt\", \"cmpilt\", \n\t\"cmpneq\", \"cmpineq\", \"cmpule\", \"cmpiule\", \"cmpult\", \"cmpiult\"\n];\nconst loadTypes = [\n\t\"lbc\", \"lbl\", \"lbm\", \"lbs\", \"lbuc\", \"lbul\", \"lbum\", \"lbus\", \"lhc\", \"lhl\", \n\t\"lhm\", \"lhs\", \"lhuc\", \"lhul\", \"lhum\", \"lhus\", \"lwc\", \"lwl\", \"lwm\", \"lws\" \n];\nconst storeTypes = [\n\t\"sbc\", \"sbl\", \"sbm\", \"sbs\", \"shc\", \"shl\", \"shm\", \"shs\", \"swc\", \"swl\", \"swm\", \"sws\" \n];\nconst mulTypes = [\n\t\"mul\", \"mulu\"\t\n];\nconst stackTypes = [\n\t\"sens\", \"sfree\", \"sres\", \"sspill\",\n\t\"sspillr\", \"sensr\",\n];\nconst predTypes = [\n\t\"pand\", \"por\", \"pxor\"\n];\nconst moveTypes = [\n\t\"mts\", \"mfs\"\n];\nconst cfTypes = [\n\t\"callnd\", \"call\", \"brnd\", \"br\", \"brcfnd\", \"brcf\", \"trap\",\n\t\"retnd\", \"ret\", \"xretnd\", \"xret\",\n\n\t// Single reg\n\t\"callndr\", \"callr\", \"brndr\", \"brr\",\n\n\t// Two reg\n\t\"brcfr\", \"brcfndr\"\n];\nconst bitCopyTypes = [\n\t\"bcopy\"\n];\n\nconst instTypes = [].concat(\n\tpseudoTypes, binTypes, compTypes, loadTypes, storeTypes, \n\tmulTypes, stackTypes, predTypes, moveTypes, cfTypes, bitCopyTypes\n);\n\nconst pseudoMapping = {\n\t\"MOV_RR\" \t: \"add {1} = {2}, 0\",  \t\t// add \n\t\"CLR\" \t\t: \"add {1} = r0, 0\", \t\t// add\n\t\"NEG\" \t\t: \"sub {1} = r0, {2}\",\t\t// sub\n\t\"NOT\" \t\t: \"nor {1} = {2}, r0\",\t\t// nor\n\t\"LI_POS\" \t: \"add {1} = r0, {2}\",\t\t// add\n\t\"LI_NEG\" \t: \"sub {1} = r0, {2}\",\t\t// sub\n\t\"NOP\"\t\t: \"sub r0 = r0, 0\", \t\t// sub\n\t\"ISODD\" \t: \"btest {1} = {2}, r0\",\t// btest\n\t\"MOV_PR\" \t: \"cmpneq {1} = {2}, r0\",\t// cmpneq\n\t\"PMOV\" \t\t: \"por {1} = {2}, {2}\",\t\t// por\n\t\"PNOT\" \t\t: \"pxor {1} = {2}, p0\",\t\t// pxor\n\t\"PSET\" \t\t: \"por {1} = p0, p0\",\t\t// por\n\t\"PCLR\"\t\t: \"pxor {1} = p0, p0\",\t\t// pxor\n\t\"MOV_RP\" \t: \"bcopy {1} = r0, 0, {2}\" \t// bcopy\n};\n\n// Checks if type is allowed in pipeline two. \nconst allowedPipelineTwo = (type) => {\n\treturn binTypes.includes(type) || compTypes.includes(type);\n};\n\nconst getInstType = (type) => {\n\tlet idx, key, keys;\n\n\tlet instTypeStr = {\n\t\tbin \t: binTypes.includes(type),\n\t\tcomp \t: compTypes.includes(type),\n\t\tload\t: loadTypes.includes(type),\n\t\tstore \t: storeTypes.includes(type),\n\t\tmul\t\t: mulTypes.includes(type),\n\t\tstack\t: stackTypes.includes(type),\n\t\tpred \t: predTypes.includes(type),\n\t\tcf \t\t: cfTypes.includes(type),\n\t};\n\t\n\tkeys = Object.keys(instTypeStr);\n\t\n\tfor (idx in keys) {\n\t\tkey = keys[idx];\n\t\tif (instTypeStr[key]) return key;\n\t}\n\treturn type;\n};\n\n\nexport { instTypes, binTypes, compTypes, loadTypes, storeTypes, mulTypes, \n\tstackTypes, predTypes, moveTypes, cfTypes, getInstType, allowedPipelineTwo,\n\tpseudoTypes, pseudoMapping };\n","// Arrays of register strings\nconst regStr = [\n\t\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \n\t\"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \n\t\"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\"\n];\nconst pregStr = [\n\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n\t\"!p0\", \"!p1\", \"!p2\", \"!p3\", \"!p4\", \"!p5\", \"!p6\", \"!p7\",\n];\nconst sregStr = [\n\t\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \n\t\"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\"\n];\nconst allRegStr = [].concat(\n\tregStr, pregStr, sregStr\n);\n\nconst sregMap = {\n\tsl : \"s2\",\n\tsh : \"s3\",\n\tss : \"s5\",\n\tst : \"s6\",\n\tsrb : \"s7\",\n\tsro : \"s8\",\n\tsxb : \"s9\",\n\tsxo : \"s10\",\n};\n\nexport { regStr, pregStr, sregStr, allRegStr, sregMap };\n","import ProcessorState from \"./ProcessorState\";\nimport { binTypes, cfTypes } from \"../../Helpers/typeStrings\";\nimport { allRegStr } from \"../../Helpers/regStrings\";\n\nclass CPU {\n\tconstructor() {\n\t\tthis.state = new ProcessorState();\n\t\tthis.history = [];\n\t\tthis.bundles = {};\n\t\tthis.pending_branch = null;\n\t\twindow.state = this.state;\n\t}\n\n\treset() {\n\t\tthis.state.reset();\n\t\tthis.history = [];\n\t\tthis.bundles = {};\n\t\tthis.pending_branch = null;\n\t}\n\n\tgetPC() {\n\t\treturn this.state.cpu[\"pc\"];\n\t}\n\n\tstep() {\n\t\tlet bundle = this.bundles[this.state.cpu.pc];\n\t\tif(!bundle) return false;\n\t\tthis.state.updateHistory();\n\t\tbundle.length === 2 ? this.dualIssue(bundle) : this.execute(bundle[0].instruction);\n\t\tif (this.pending_branch) this.handlePendingBranch();\n\t\treturn true;\n\t}\n\n\tdualIssue(bundle) {\n\t\t// slight spaghetti to ensure that bundles like (p0) addi r1 = r0, 5 || (p0) addi r2 = r1, 5; work\n\t\tlet conflicts = {};\n\t\tfor(let op of bundle[0].ops){\n\t\t\tif(allRegStr.includes(op) && bundle[1].ops.includes(op)){\n\t\t\t\tconflicts[op] = {};\n\t\t\t}\n\t\t\t// store original values\n\t\t\tfor(let conflict in conflicts){\n\t\t\t\tconflicts[conflict].prev = this.state.reg[conflict];\n\t\t\t}\n\t\t\t// execute\n\t\t\tthis.execute(bundle[1].instruction);\n\t\t\t// store and reset\n\t\t\tfor(let conflict in conflicts){\n\t\t\t\tconflicts[conflict].next = this.state.reg[conflict];\n\t\t\t\tif(conflicts[conflict].prev !== conflicts[conflict].next){\n\t\t\t\t\tthis.state.reg[conflict] = conflicts[conflict].prev;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// execute\n\t\t\tthis.execute(bundle[0].instruction);\n\t\t\t// recover\n\t\t\tfor(let conflict in conflicts){\n\t\t\t\tthis.state.reg[conflict] = conflicts[conflict].next;\n\t\t\t}\n\t\t}\n\t\t// execute\n\t\tthis.execute(bundle[1].instruction);\n\t\t// recover\n\t\tfor(let conflict in conflicts){\n\t\t\tthis.state.reg[conflict] = conflicts[conflict].next;\n\t\t}\n\t}\n\n\thandlePendingBranch() {\n\t\tif(this.pending_branch.delay !== 0){\n\t\t\tthis.pending_branch.delay--;\n\t\t} else {\n\t\t\tif(this.pending_branch.inst.name === \"br\"){\n\t\t\t\tthis.state.cpu.pc = this.pending_branch.pc;\n\t\t\t} else {\n\t\t\t\tthis.state.cpu.pc -= 4;\n\t\t\t}\n\t\t\tthis.pending_branch.inst.execute(this.state);\n\t\t\tthis.pending_branch = null;\n\t\t}\n\t}\n\n\t// Step one instruction backwards in queue\n\tprev() {\n\t\tthis.state.rewindOnce();\n\t}\n\n\t// Run all instructions.\n\trun() {\n\t\tlet n = 0;\n\t\tlet start, end;\n\t\tstart = performance.now();\n\t\twhile(this.bundles[this.state.cpu.pc]){\n\t\t\tthis.step();\n\t\t\tn++;\n\t\t}\n\t\tend = performance.now();\n\t\tconsole.log(n, \"bundles executed in\", end-start, \"ms.\");\n\t\tconsole.log(n/((end-start)/1000), \"bundles pr. second.\");\n\n\t}\n\n\t/**\n\t * Map bundle array to corresponding offsets\n\t * @param {Object[]} bundles - An array of bundle objects.\n\t */\n\tpopulate(bundles){\n\t\tthis.reset();\n\t\tlet bundle, addr, base_set = false;\n\n\t\tfor(bundle of bundles){\n\t\t\taddr = bundle.offset;\n\t\t\tif(bundle.is_data){\n\t\t\t\tswitch(bundle.data.type){\n\t\t\t\t\tcase \"word\":\n\t\t\t\t\t\tthis.state.mem[addr + 3] = bundle.data.value & 0xFF;\n\t\t\t\t\t\tthis.state.mem[addr + 2] = (bundle.data.value >> 8) & 0xFF;\n\t\t\t\t\t\tthis.state.mem[addr + 1] = (bundle.data.value >> 16) & 0xFF;\n\t\t\t\t\t\tthis.state.mem[addr + 0] = (bundle.data.value >> 24) & 0xFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(!base_set){\n\t\t\t\t\tthis.state.cpu.base = addr;\n\t\t\t\t\tthis.state.cpu.pc = addr;\n\t\t\t\t\tbase_set = true;\n\t\t\t\t}\n\t\t\t\tthis.bundles[addr] = bundle.instructions;\n\t\t\t\tthis.setMem(addr, bundle);\n\t\t\t}\n\t\t}\n\n\t\tif (bundle === undefined)\n\t\t\treturn false;\n\n\t\tthis.state.mem[\"TEXT_END\"] = Number(addr) + bundle.size;\n\t\treturn true;\n\t}\n\n\tsetMem(addr, bundle){\n\t\tlet o = 0;\n\t\tfor(let inst of bundle.instructions){\n\t\t\tfor(let int of inst.instruction.binary){\n\t\t\t\tthis.state.mem[addr + o + 3] = int & 0xFF;\n\t\t\t\tthis.state.mem[addr + o + 2] = (int >> 8) & 0xFF;\n\t\t\t\tthis.state.mem[addr + o + 1] = (int >> 16) & 0xFF;\n\t\t\t\tthis.state.mem[addr + o + 0] = (int >> 24) & 0xFF;\n\t\t\t\to += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n \t* @param {Object} inst - Instruction object\n\t*/\n\texecute(inst) {\n\t\tif ( ((inst.pred & 0b1000) >>> 3) !== this.state.reg[`p${inst.pred & 0b0111}`] ) {\n\t\t\tif(!cfTypes.includes(inst.name) || inst.name.includes(\"nd\")){\n\t\t\t\tinst.execute(this.state);\n\t\t\t} else {\n\t\t\t\tlet delay = 0;\n\t\t\t\tswitch(inst.name){\n\t\t\t\t\tcase \"br\":\n\t\t\t\t\t\tdelay = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tdelay = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.pending_branch = { delay, inst, pc: this.state.cpu.pc };\n\t\t\t\tthis.state.cpu.pc += 4;\n\t\t\t}\n\t\t} else if (cfTypes.includes(inst.name)){\n\t\t\tthis.state.cpu.pc += 4;\n\t\t}\n\n\t\tif(binTypes.includes(inst.name) && inst.type === \"l\") {\n\t\t\tthis.state.cpu.pc += 8;\n\t\t} else if(!cfTypes.includes(inst.name)){\n\t\t\tthis.state.cpu.pc += 4;\n\t\t}\n\t\tthis.setReadReg();\n\t}\n\n\tgetReg() {\n\t\treturn this.state.getReg();\n\t}\n\n\tgetMem() {\n\t\treturn this.state.getMemory();\n\t}\n\n\tsetReadReg() {\n\t\tthis.state.reg.r0 = 0;\n\t\tthis.state.reg.p0 = 1;\n\t\tthis.state.reg.s0 = 0;\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tthis.state.reg.s0 |= this.state.reg[`p${i}`] << i;\n\t\t}\n\t}\n}\n\nexport default CPU;\n","import { compile_reg, compile_imm, compile_long } from \"./compilers\";\n\n/** \n * Represents a BinaryArithmetics instruction. Sets common fields. \n */\nclass BinaryArithmetics {\n\t/**\n     * Create base instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string}          fields.name - Name of instruction\n     * @param {number}          fields.func - Instruction function\n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ name, func, pred, rd, rs1, op2 }) {\n\t\tthis.type = isNaN(op2) ? \"r\" : (Number(op2) > 0x0FFF ? \"l\" : \"i\");\n\t\tthis.pred = pred;\n\t\tthis.rd = rd;\n\t\tthis.rs1 = rs1;\n\t\tthis.op2 = op2;\n\t\tthis.name = name;\n\t\tthis.func = func;\n        \n\t\t// nor, shadd, shadd2 does not have an immediate format\n\t\tif([0b1011, 0b1100, 0b1101].includes(func) && this.type === \"i\"){\n\t\t\tthis.type = \"l\";\n\t\t}\n\n\t\tswitch (this.type) {\n\t\t\tcase \"r\":\n\t\t\t\tthis.binary = compile_reg(pred, rd, rs1, op2, func);\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis.op2 &= 0xFFF;\n\t\t\t\tthis.binary = compile_imm(pred, func, rd, rs1, op2);\n\t\t\t\tbreak;\n\t\t\tcase \"l\":\n\t\t\t\tthis.binary = compile_long(pred, rd, rs1, func, op2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\n\t\t}\n\t}\n    \n\texecute(){\n\t\tthrow new Error(\"Missing execute handler for\", this);\n\t}\n\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.rs1}, ${this.op2}`;\n\t}\n}\n\nexport default BinaryArithmetics;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\n\nexport const compile_reg = (pred, rd, rs1, rs2, func) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\tfunc = parseNum(func);\n\trd = parseReg(rd);\n\trs1 = parseReg(rs1);\n\trs2 = parseReg(rs2);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01000 << 22;\n\tbinary[0] |= rd << 17;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= rs2 << 7;\n\tbinary[0] |= func << 0;\n\n\treturn binary;\n};\n\nexport const compile_imm = (pred, func, rd, rs1, imm) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\tfunc = parseNum(func);\n\timm = parseNum(imm);\n\trd = parseReg(rd);\n\trs1 = parseReg(rs1);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= (func & 0x7) << 22;\n\tbinary[0] |= rd << 17;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= imm << 0;\n\n\treturn binary;\n};\n\nexport const compile_long = (pred, rd, rs1, func, long) => {\n\tlet binary = [0, 0];\n\n\tpred = parseNum(pred);\n\tfunc = parseNum(func);\n\tlong = parseNum(long);\n\trd = parseReg(rd);\n\trs1 = parseReg(rs1);\n\n\tbinary[0] |= 1 << 31;\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b11111 << 22;\n\tbinary[0] |= rd << 17;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= func;\n\tbinary[1] = long & 0xFFFFFFFF;\n    \n\treturn binary;\n};\n","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Addition instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass Add extends BinaryArithmetics {\n\t/**\n     * Create Add instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"add\", func: 0, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = (reg[this.rs1] + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\n\t}\n}\n\nexport default Add;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Negated Bitwise OR instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass Nor extends BinaryArithmetics {\n\t/**\n     * Create Nor instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"nor\", func: 11, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = ~((reg[this.rs1] | (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0);\n\t}\n}\n\nexport default Nor;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Shift-by-1-then-Add instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass ShiftAdd extends BinaryArithmetics {\n\t/**\n     * Create ShiftAdd instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"shadd\", func: 12, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = ((reg[this.rs1] << 1) + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\n\t}\n}\n\nexport default ShiftAdd;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Shift-by-2-then-Add instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass ShiftAdd2 extends BinaryArithmetics {\n\t/**\n     * Create ShiftAdd2 instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"shadd2\", func: 13, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = ((reg[this.rs1] << 2) + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\n\t}\n}\n\nexport default ShiftAdd2;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Shift left instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass ShiftLeft extends BinaryArithmetics {\n\t/**\n     * Create ShiftLeft instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"sl\", func: 3, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = (reg[this.rs1] << (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\n\t}\n}\n\nexport default ShiftLeft;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Shift right instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass ShiftRight extends BinaryArithmetics {\n\t/**\n     * Create ShiftRight instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"sr\", func: 4, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = (reg[this.rs1] >>> (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\n\t}\n}\n\nexport default ShiftRight;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Shift right arithmetic instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass ShiftRightArithmetic extends BinaryArithmetics {\n\t/**\n     * Create ShiftRightArithmetic instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"sra\", func: 5, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = (reg[this.rs1] >> (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\n\t}\n}\n\nexport default ShiftRightArithmetic;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Subtraction instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass Sub extends BinaryArithmetics {\n\t/**\n     * Create Sub instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"sub\", func: 1, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = (reg[this.rs1] - (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\n\t}\n}\n\nexport default Sub;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Bitwise Exclusive OR instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass Xor extends BinaryArithmetics {\n\t/**\n     * Create Xor instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"xor\", func: 2, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = (reg[this.rs1] ^ (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\n\t}\n}\n\nexport default Xor;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * Or instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass Or extends BinaryArithmetics {\n\t/**\n     * Create Or instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"or\", func: 6, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = reg[this.rs1] | (this.type === \"r\" ? reg[this.op2] : Number(this.op2));\n\t}\n}\n\nexport default Or;","import BinaryArithmetics from \"./BinaryArithmetics\";\n\n/** \n * And instruction class. \n * @extends BinaryArithmetics\n * @category BinaryArithmetics\n */\nclass And extends BinaryArithmetics {\n\t/**\n     * Create And instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, rd, rs1, op2 }) {\n\t\tsuper({ name: \"and\", func: 7, pred, rd, rs1, op2 });\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = reg[this.rs1] & (this.type === \"r\" ? reg[this.op2] : Number(this.op2));\n\t}\n}\n\nexport default And;","import { compile_reg, compile_imm } from \"./compilers\";\n\n/** \n * Represents a Compare instruction. Sets common fields. \n */\nclass Compare {\n\t/**\n     * Create base instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string}          fields.name - Name of instruction\n     * @param {number}          fields.func - Instruction function\n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.pd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ name, pred, pd, rs1, op2, func }) {\n\t\tthis.type = isNaN(op2) ? \"r\" : \"i\";\n\t\tthis.pred = pred;\n\t\tthis.pd = pd;\n\t\tthis.rs1 = rs1;\n\t\tthis.op2 = op2;\n\t\tthis.name = name;\n\t\tthis.func = func;\n\n\t\tswitch (this.type) {\n\t\t\tcase \"r\":\n\t\t\t\tthis.binary = compile_reg(pred, pd, rs1, op2, func);\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis.op2 &= 0x1F;\n\t\t\t\tthis.binary = compile_imm(pred, pd, rs1, op2, func);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\n\t\t}\n\t}\n    \n\texecute(){\n\t\tthrow new Error(\"Missing execute handler for\", this);\n\t}\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.pd} = ${this.rs1}, ${this.op2}`;\n\t}\n}\n\nexport default Compare;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\n\nexport const compile_reg = (pred, pd, rs1, rs2, func) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\tfunc = parseNum(func);\n\tpd = parseReg(pd);\n\trs1 = parseReg(rs1);\n\trs2 = parseReg(rs2);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01000 << 22;\n\tbinary[0] |= pd << 17;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= rs2 << 7;\n\tbinary[0] |= 0b011 << 4;\n\tbinary[0] |= func << 0;\n\n\treturn binary;\n};\n\nexport const compile_imm = (pred, pd, rs1, imm, func) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\tfunc = parseNum(func);\n\timm = parseNum(imm);\n\tpd = parseReg(pd);\n\trs1 = parseReg(rs1);\n    \n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01000 << 22;\n\tbinary[0] |= pd << 17;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= ((imm & 0x1F) << 7);\n\tbinary[0] |= 0b110 << 4;\n\tbinary[0] |= func << 0;\n    \n\treturn binary;\n};\n\n","import Compare from \"./Compare\";\n\n/** \n * Btest instruction class. \n * @extends Compare\n * @category Compare\n */\nclass Btest extends Compare {\n\t/**\n     * Create Btest instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.pd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, pd, rs1, op2 }) {\n\t\tsuper({name: \"btest\", func: 0b0110, pred, pd, rs1, op2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state       - Processor state\n     * @param {Object.<string, number>} state.reg   - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = Number((reg[this.rs1] & ( 1 << (this.type === \"r\" ? reg[this.op2] : Number(this.op2) & 0x1F ))) !== 0);\n\t}\n}\n\nexport default Btest;\n","import Compare from \"./Compare\";\n\n/** \n * Cmpeq instruction class. \n * @extends Compare\n * @category Compare\n */\nclass Cmpeq extends Compare {\n\t/**\n     * Create Cmpeq instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.pd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, pd, rs1, op2 }) {\n\t\tsuper({name: \"cmpeq\", func: 0b0000, pred, pd, rs1, op2});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = Number(reg[this.rs1] === (this.type === \"r\" ? \n\t\t\treg[this.op2] : ((Number(this.op2) << 27) >> 27)));\n\t}\n}\n\nexport default Cmpeq;\n","import Compare from \"./Compare\";\n\n/** \n * Btest instruction class. \n * @extends Compare\n * @category Compare\n */\nclass Cmple extends Compare {\n\t/**\n     * Create Cmple instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.pd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, pd, rs1, op2 }) {\n\t\tsuper({name: \"cmple\", func: 0b0011, pred, pd, rs1, op2});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state       - Processor state\n     * @param {Object.<string, number>} state.reg   - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = Number(reg[this.rs1] <= (this.type === \"r\" ? \n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\n\t}\n}\n\nexport default Cmple;\n","import Compare from \"./Compare\";\n\n/** \n * Cmplt instruction class. \n * @extends Compare\n * @category Compare\n */\nclass Cmplt extends Compare {\n\t/**\n     * Create Cmplt instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.pd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, pd, rs1, op2 }) {\n\t\tsuper({name: \"cmplt\", func: 0b0010, pred, pd, rs1, op2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state       - Processor state\n     * @param {Object.<string, number>} state.reg   - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = Number(reg[this.rs1] < (this.type === \"r\" ? \n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\n\t}\n}\n\nexport default Cmplt;\n","import Compare from \"./Compare\";\n\n/** \n * Cmpneq instruction class. \n * @extends Compare\n * @category Compare\n */\nclass Cmpneq extends Compare {\n\t/**\n     * Create Cmpneq instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.pd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, pd, rs1, op2 }) {\n\t\tsuper({name: \"cmpneq\", func: 0b0001, pred, pd, rs1, op2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state       - Processor state\n     * @param {Object.<string, number>} state.reg   - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = Number(reg[this.rs1] !== (this.type === \"r\" ? \n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\n\t}\n}\n\nexport default Cmpneq;\n","import Compare from \"./Compare\";\n\n/** \n * Cmpule instruction class. \n * @extends Compare\n * @category Compare\n */\nclass Cmpule extends Compare {\n\t/**\n     * Create Cmpule instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.pd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, pd, rs1, op2 }) {\n\t\tsuper({name: \"cmpule\", func: 0b0101, pred, pd, rs1, op2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state       - Processor state\n     * @param {Object.<string, number>} state.reg   - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = Number((reg[this.rs1] >>> 0) <= ((this.type === \"r\" ? \n\t\t\treg[this.op2] : Number(this.op2)) >>> 0));\n\t}\n}\n\nexport default Cmpule;\n","import Compare from \"./Compare\";\n\n/** \n * Cmpult instruction class. \n * @extends Compare\n * @category Compare\n */\nclass Cmpult extends Compare {\n\t/**\n     * Create Cmpult instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.pd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, pd, rs1, op2 }) {\n\t\tsuper({name: \"cmpult\", func: 0b0100, pred, pd, rs1, op2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state       - Processor state\n     * @param {Object.<string, number>} state.reg   - Registers\n     */   execute( { reg } ) {\n\t\treg[this.pd] = \n\t\t\tNumber((reg[this.rs1] >>> 0) < ((this.type === \"r\" ? \n\t\t\t\treg[this.op2] : Number(this.op2))) >>> 0);\n\t}\n}\n\nexport default Cmpult;\n","import { compile_reg, compile_reg2, compile_ireg, compile_imm } from \"./compilers\";\n\n/** \n * Represents a ControlFlow instruction. Sets common fields. \n */\nclass ControlFLow {\n\t/**\n     * Create base instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string}          fields.name - Name of instruction\n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.op   - Type of control\n\t * @param {string}          fields.s1   - Either source register or immediate value\n\t * @param {string}          fields.s2   - Source register 2.\n     */\n\tconstructor({ name, pred, d, op, s1, s2 }) {\n\t\tthis.type = (!s1 && !s2) ? \"implicit\" : (isNaN(s1) ? (!s2 ? \"single_reg\" : \"two_reg\") : \"immediate\");\n\t\tthis.name = name;\n\t\tthis.pred = pred;\n\t\tthis.d = d;\n\t\tthis.op = op;\n\t\tthis.s1 = s1;\n\t\tthis.s2 = s2;\n\n\t\tswitch(this.type){\n\t\t\tcase \"implicit\":\n\t\t\t\tthis.binary = compile_ireg(this.pred, this.d, this.op);\n\t\t\t\tbreak;\n\t\t\tcase \"single_reg\":\n\t\t\t\tthis.binary = compile_reg(this.pred, this.d, this.op, this.s1);\n\t\t\t\tbreak;\n\t\t\tcase \"two_reg\":\n\t\t\t\tthis.binary = compile_reg2(this.pred, this.d, this.op, this.s1, this.s2);\n\t\t\t\tbreak;\n\t\t\tcase \"immediate\":\n\t\t\t\tthis.s1 &= 0x3FFFFF;\n\t\t\t\tthis.binary = compile_imm(this.pred, this.op, this.d, this.s1);\n\t\t\t\tthis.s1 = (Number(this.s1) << 10) >> 8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\n\t\t}\n\t}\n\texecute(){\n\t\tthrow new Error(\"Missing execute handler for\", this);\n\t}\n\ttoString(){\n\t\tlet s1 = this.s1 ? isNaN(this.s1) ? this.s1 : this.s1 >> 2 : \"\";\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${s1} ${this.s2 ? \", \"+this.s2 : \"\"}`;\n\t}\n}\n\nexport default ControlFLow;\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\n\nexport const compile_reg = (pred, d, op, rs1) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\td = parseNum(d);\n\top = parseNum(op);\n\trs1 = parseReg(rs1);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b1100 << 23;\n\tbinary[0] |= d << 22;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= 0b01 << 2;\n\tbinary[0] |= op << 0;\n\n\treturn binary;\n};\n\nexport const compile_reg2 = (pred, d, op, rs1, rs2) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\td = parseNum(d);\n\top = parseNum(op);\n\trs1 = parseReg(rs1);\n\trs2 = parseReg(rs2);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b1100 << 23;\n\tbinary[0] |= d << 22;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= rs2 << 7;\n\tbinary[0] |= 0b10 << 2;\n\tbinary[0] |= op << 0;\n\n\treturn binary;\n};\n\nexport const compile_ireg = (pred, d, op) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\td = parseNum(d);\n\top = parseNum(op);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b1100 << 23;\n\tbinary[0] |= d << 22;\n\tbinary[0] |= 0b00 << 2;\n\tbinary[0] |= op << 0;\n\n\treturn binary;\n};\n\nexport const compile_imm = (pred, op, d, imm) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\top = parseNum(op);\n\td = parseNum(d); \n\timm = parseNum(imm);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b10 << 25;\n\tbinary[0] |= op << 23;\n\tbinary[0] |= d << 22;\n\tbinary[0] |= imm << 0;\n\n\treturn binary;\n};\n\n","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Br instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Br extends ControlFlow {\n\t/**\n     * Create Br instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"br\", d: 1, op: 0b01, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\n\t\tcpu.pc = this.type === \"immediate\" ? cpu.pc + addr : addr;\n\t}\n}\n\nexport default Br;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Br instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Brcf extends ControlFlow {\n\t/**\n     * Create Brcf instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"brcf\", d: 1, op: 0b10, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\n\t\tlet offset = this.type === \"two_reg\" ? reg[this.s2] : 0;\n\t\tcpu.base = addr;\n\t\tcpu.pc = addr + offset;\n\t}\n}\n\nexport default Brcf;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Br instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Brcfnd extends ControlFlow {\n\t/**\n     * Create Brcfnd instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"brcfnd\", d: 0, op: 0b10, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\n\t\tlet offset = this.type === \"two_reg\" ? reg[this.s2] : 0;\n\t\tcpu.base = addr;\n\t\tcpu.pc = addr + offset;\n\t}\n}\n\nexport default Brcfnd;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Brnd instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Brnd extends ControlFlow {\n\t/**\n     * Create Brnd instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"brnd\", d: 0, op: 0b01, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\n\t\tcpu.pc = (this.type === \"immediate\" ? cpu.pc + addr : addr);\n\t}\n}\n\nexport default Brnd;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Call instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Call extends ControlFlow {\n\t/**\n     * Create Call instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"call\", d: 1, op: 0b00, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\n\t\treg.s7 = cpu.base; \t// srb\n\t\treg.s8 = cpu.pc;\t// sro\n\t\tcpu.base = addr;\n\t\tcpu.pc = addr; \t\t// should be offset(addr) but as we have no cache...\n\t}\n}\n\nexport default Call;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Call instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Callnd extends ControlFlow {\n\t/**\n     * Create Callnd instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"callnd\", d: 0, op: 0b00, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\tlet addr = this.type === \"immediate\" ? this.s1 : reg[this.s1];\n\t\treg.s7 = cpu.base;\t// srb\n\t\treg.s8 = cpu.pc;\t// sro\n\t\tcpu.base = addr;\n\t\tcpu.pc = addr; \t\t// should be offset(addr) but as we have no cache...\n\t}\n}\n\nexport default Callnd;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Ret instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Ret extends ControlFlow {\n\t/**\n     * Create Ret instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"ret\", d: 1, op: 0b00, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\t//srb s7, sro s8\n\t\tcpu.base = reg.s7;\n\t\tcpu.pc = reg.s8 + 4; //should be offset(srb) + sro, but as we don't have cache. Also +4 is to set it to the next instruction.\n\t}\n}\n\nexport default Ret;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Retnd instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Retnd extends ControlFlow {\n\t/**\n     * Create Retnd instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"retnd\", d: 0, op: 0b00, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\t//srb s7, sro s8\n\t\tcpu.base = reg.s7;\n\t\tcpu.pc = reg.s8 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\n\t}\n}\n\nexport default Retnd;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Trap instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Trap extends ControlFlow {\n\t/**\n     * Create Trap instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"trap\", d: 0, op: 0b11, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\tlet addr = 0xf0010080 + this.s1;\t//exception table base addr: 0xF0010080\n\t\treg.s9 = cpu.base; \t\t\t\t\t// sxb\n\t\treg.s10 = cpu.pc;\t\t\t\t\t// sxo\n\t\tcpu.base = addr;\n\t\tcpu.pc = addr; \t\t\t\t\t\t// should be offset(addr) but as we have no cache...\n\t}\n}\n\nexport default Trap;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Xret instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Xret extends ControlFlow {\n\t/**\n     * Create Xret instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"xret\", d: 1, op: 0b01, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\t//sxb s9, sxo s10\n\t\tcpu.base = reg.s9;\n\t\tcpu.pc = reg.s10 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\n\t}\n}\n\nexport default Xret;","import ControlFlow from \"./ControlFlow\";\n\n/** \n * Xretnd instruction class. \n * @extends ControlFlow\n * @category ControlFlow\n */\nclass Xretnd extends ControlFlow {\n\t/**\n     * Create Xretnd instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\n     */\n\tconstructor({ pred, s1, s2 }) {\n\t\tsuper({ name: \"xretnd\", d: 0, op: 0b01, pred, s1, s2 });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state           - Processor state\n     * @param {Object.<string, number>} state.reg       - Registers\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\n     * @param {number}                  state.cpu.base  - Base address\n     * @param {number}                  state.cpu.pc    - Program counter\n     */\n\texecute({ reg, cpu }) {\n\t\t//sxb s9, sxo s10\n\t\tcpu.base = reg.s9;\n\t\tcpu.pc = reg.s10 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\n\t}\n}\n\nexport default Xretnd;","import { compile_reg } from \"./compilers\";\nimport { toUint32 } from \"../../../Helpers/misc\";\n\n/** \n * Represents a LoadTyped instruction. Sets common fields. \n */\nclass LoadTyped {\n\t/**\n     * Create base instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string}          fields.name - Name of instruction\n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n     * @param {string}   \t\tfields.type - Instruction type\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ name, pred, rd, ra, type, imm }) {\n\t\tthis.name = name;\n\t\tthis.pred = pred;\n\t\tthis.rd = rd;\n\t\tthis.ra = ra;\n\t\tthis.type = type;\n\t\tthis.imm = toUint32(imm) & 0x7F;\t// Imm is interpreted unsigned\n\t\tthis.binary = compile_reg(pred, rd, ra, type, imm);\n\t}\n\n\texecute() {\n\t\tthrow new Error(\"Missing execute handler for\", this);\n\t}\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = [${this.ra} + ${this.imm}]`;\n\t}\n}\nexport default LoadTyped;\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\n\nexport const compile_reg = (pred, rd, ra, type, imm) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\timm = parseNum(imm);\n\ttype = parseNum(type);\n\trd = parseReg(rd);\n\tra = parseReg(ra);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01010 << 22;\n\tbinary[0] |= rd << 17;\n\tbinary[0] |= ra << 12;\n\tbinary[0] |= type << 7;\n\tbinary[0] |= imm << 0;\n\n\treturn binary;\n};\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lws instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lws extends LoadTyped {\n\t/**\n     * Create Lws instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lws\", pred, rd, ra, type: 0b00000, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 2);\n\t\tlet hh = mem[reg[\"s6\"] + address + 0];\n\t\tlet hl = mem[reg[\"s6\"] + address + 1];\n\t\tlet lh = mem[reg[\"s6\"] + address + 2];\n\t\tlet ll = mem[reg[\"s6\"] + address + 3];\n\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\n\t}\n}\n\nexport default Lws;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lwl instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lwl extends LoadTyped{\n\t/**\n     * Create Lwl instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lwl\", pred, rd, ra, type: 0b00001, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 2);\n\t\tlet hh = mem[address + 0];\n\t\tlet hl = mem[address + 1];\n\t\tlet lh = mem[address + 2];\n\t\tlet ll = mem[address + 3];\n\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\n\t}\n}\n\nexport default Lwl;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lwc instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lwc extends LoadTyped {\n\t/**\n     * Create Lwc instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lwc\", pred, rd, ra, type: 0b00010, imm });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 2);\n\t\tlet hh = mem[address + 0];\n\t\tlet hl = mem[address + 1];\n\t\tlet lh = mem[address + 2];\n\t\tlet ll = mem[address + 3];\n\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\n\t}\n}\n\nexport default Lwc;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lwm instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lwm extends LoadTyped {\n\t/**\n   * Create Lwm instruction.\n   * @param {Object}          fields      - Fields to set \n   * @param {string|number}   fields.pred - Instruction predicate\n   * @param {string}          fields.rd   - Destination register\n   * @param {string}          fields.ra  \t- First source register\n   * @param {number}\t\t\tfields.imm\t- Immediate value \n   */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lwm\", pred, rd, ra, type: 0b00011, imm });\n\t}\n\n\t/**\n   * Executes the instruction\n   * @param {Object}                  state        - Processor state\n   * @param {Object.<string, number>} state.reg    - Registers\n   */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 2);\n\t\tlet hh = mem[address + 0];\n\t\tlet hl = mem[address + 1];\n\t\tlet lh = mem[address + 2];\n\t\tlet ll = mem[address + 3];\n\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\n\t}\n}\n\nexport default Lwm;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lhs instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lhs extends LoadTyped {\n\t/**\n   * Create Lhs instruction.\n   * @param {Object}          fields      - Fields to set \n   * @param {string|number}   fields.pred - Instruction predicate\n   * @param {string}          fields.rd   - Destination register\n   * @param {string}          fields.ra  \t- First source register\n   * @param {number}\t\t\tfields.imm\t- Immediate value \n   */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lhs\", pred, rd, ra, type: 0b00100, imm });\n\t}\n\n\t/**\n   * Executes the instruction\n   * @param {Object}                  state        - Processor state\n   * @param {Object.<string, number>} state.reg    - Registers\n   */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 1);\n\t\tlet hi = mem[reg[\"s6\"] + address + 0];\n\t\tlet lo = mem[reg[\"s6\"] + address + 1];\n\t\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16;\n\t}\n}\n\nexport default Lhs;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lhl instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lhl extends LoadTyped{\n\t/**\n     * Create Lhl instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lhl\", pred, rd, ra, type: 0b00101, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 1);\n\t\tlet hi = mem[address + 0];\n\t\tlet lo = mem[address + 1];\n\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \n\t}\n}\n\nexport default Lhl;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lhc instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lhc extends LoadTyped{\n\t/**\n     * Create Lhc instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lhc\", pred, rd, ra, type: 0b00110, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 1);\n\t\tlet hi = mem[address + 0];\n\t\tlet lo = mem[address + 1];\n\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \n\t}\n\n}\n\nexport default Lhc;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lhm instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lhm extends LoadTyped{\n\t/**\n     * Create Lhm instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lhm\", pred, rd, ra, type: 0b00111, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 1);\n\t\tlet hi = mem[address + 0];\n\t\tlet lo = mem[address + 1];\n\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \n\t}\n}\n\nexport default Lhm;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lbs instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lbs extends LoadTyped {\n\t/**\n\t * Create Lbs instruction.\n\t * @param {Object}          fields      - Fields to set \n\t * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {string}          fields.rd   - Destination register\n\t * @param {string}          fields.ra  \t- First source register\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \n\t */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lbs\", pred, rd, ra, type: 0b01000, imm });\n\t}\n\n\t/**\n\t * Executes the instruction\n\t * @param {Object}                  state        - Processor state\n\t * @param {Object.<string, number>} state.reg    - Registers\n\t */\n\texecute({ reg, mem }) {\n\t\treg[this.rd] = (mem[reg[\"s6\"] + reg[this.ra] + this.imm] << 24) >> 24;\n\t}\n\n}\n\nexport default Lbs;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lbl instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lbl extends LoadTyped {\n\t/**\n     * Create Lbl instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lbl\", pred, rd, ra, type: 0b01001, imm });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\n\t}\n}\n\nexport default Lbl;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lbc instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lbc extends LoadTyped {\n\t/**\n     * Create Lbc instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n     * @param {string}   \t\tfields.type - Second operand. Can be a second source register or immediate value.\n     * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lbc\", pred, rd, ra, type: 0b01010, imm });\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\n\t}\n}\n\nexport default Lbc;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lbm instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lbm extends LoadTyped {\n\t/**\n\t * Create Lbm instruction.\n\t * @param {Object}          fields      - Fields to set \n\t * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {string}          fields.rd   - Destination register\n\t * @param {string}          fields.ra  \t- First source register\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \n\t */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lbm\", pred, rd, ra, type: 0b01011, imm });\n\t}\n\n\t/**\n\t * Executes the instruction\n\t * @param {Object}                  state        - Processor state\n\t * @param {Object.<string, number>} state.reg    - Registers\n\t */\n\texecute({ reg, mem }) {\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\n\t}\n}\n\nexport default Lbm;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lhus instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lhus extends LoadTyped {\n\t/**\n   * Create Lhus instruction.\n   * @param {Object}          fields      - Fields to set \n   * @param {string|number}   fields.pred - Instruction predicate\n   * @param {string}          fields.rd   - Destination register\n   * @param {string}          fields.ra  \t- First source register\n   * @param {number}\t\t\tfields.imm\t- Immediate value \n   */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lhus\", pred, rd, ra, type: 0b01100, imm });\n\t}\n\n\t/**\n   * Executes the instruction\n   * @param {Object}                  state        - Processor state\n   * @param {Object.<string, number>} state.reg    - Registers\n   */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 1);\n\t\tlet hi = mem[reg[\"s6\"] + address + 0];\n\t\tlet lo = mem[reg[\"s6\"] + address + 1];\n\n\t\treg[this.rd] = (hi << 8) | lo;\n\t}\n}\n\nexport default Lhus;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lhul instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lhul extends LoadTyped {\n\t/**\n   * Create Lhul instruction.\n   * @param {Object}          fields      - Fields to set \n   * @param {string|number}   fields.pred - Instruction predicate\n   * @param {string}          fields.rd   - Destination register\n   * @param {string}          fields.ra  \t- First source register\n   * @param {number}\t\t\tfields.imm\t- Immediate value \n   */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lhul\", pred, rd, ra, type: 0b01101, imm });\n\t}\n\n\t/**\n   * Executes the instruction\n   * @param {Object}                  state        - Processor state\n   * @param {Object.<string, number>} state.reg    - Registers\n   */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 1);\n\t\tlet hi = mem[address + 0];\n\t\tlet lo = mem[address + 1];\n\t\n\t\treg[this.rd] = (hi << 8) | lo;\n\t}\n}\n\nexport default Lhul;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lhuc instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lhuc extends LoadTyped {\n\t/**\n   * Create Lhuc instruction.\n   * @param {Object}          fields      - Fields to set \n   * @param {string|number}   fields.pred - Instruction predicate\n   * @param {string}          fields.rd   - Destination register\n   * @param {string}          fields.ra  \t- First source register\n   * @param {number}\t\t\tfields.imm\t- Immediate value \n   */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lhuc\", pred, rd, ra, type: 0b01110, imm });\n\t}\n\n\t/**\n   * Executes the instruction\n   * @param {Object}                  state        - Processor state\n   * @param {Object.<string, number>} state.reg    - Registers\n   */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 1);\n\t\tlet hi = mem[address + 0];\n\t\tlet lo = mem[address + 1];\n\n\t\treg[this.rd] = (hi << 8) | lo;\n\t}\n}\n\nexport default Lhuc;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lhum instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lhum extends LoadTyped {\n\t/**\n   * Create Lhum instruction.\n   * @param {Object}          fields      - Fields to set \n   * @param {string|number}   fields.pred - Instruction predicate\n   * @param {string}          fields.rd   - Destination register\n   * @param {string}          fields.ra  \t- First source register\n   * @param {number}\t\t\tfields.imm\t- Immediate value \n   */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({ name: \"lhum\", pred, rd, ra, type: 0b01111, imm });\n\t}\n\n\t/**\n   * Executes the instruction\n   * @param {Object}                  state        - Processor state\n   * @param {Object.<string, number>} state.reg    - Registers\n   */\n\texecute({ reg, mem }) {\n\t\tlet address = reg[this.ra] + (this.imm << 1);\n\t\tlet hi = mem[address + 0];\n\t\tlet lo = mem[address + 1];\n\n\t\treg[this.rd] = (hi << 8) | lo;\n\t}\n}\n\nexport default Lhum;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lbus instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lbus extends LoadTyped{\n\t/**\n     * Create Lbus instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lbus\", pred, rd, ra, type: 0b10000, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\treg[this.rd] = mem[reg[\"s6\"] + reg[this.ra] + this.imm] & 0xFF; \n\t}\n}\n\nexport default Lbus;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lbul instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lbul extends LoadTyped{\n\t/**\n     * Create Lbul instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lbul\", pred, rd, ra, type: 0b10001, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \n\t}\n}\n\nexport default Lbul;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lbuc instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lbuc extends LoadTyped{\n\t/**\n     * Create Lbuc instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lbuc\", pred, rd, ra, type: 0b10010, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \n\t}\n}\n\nexport default Lbuc;\n","import LoadTyped from \"./LoadTyped\";\n\n/** \n * Lbum instruction class. \n * @extends LoadTyped\n * @category LoadTyped\n */\nclass Lbum extends LoadTyped{\n\t/**\n     * Create Lbum instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.ra  \t- First source register\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \n     */\n\tconstructor({ pred, rd, ra, imm }) {\n\t\tsuper({name: \"lbum\", pred, rd, ra, type: 0b10011, imm});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \n\t}\n}\n\nexport default Lbum;\n","import { compile_reg } from \"./compilers\";\n\n/** \n * Represents a Multiply instruction. Sets common fields. \n */\nclass Multiply {\n\t/**\n     * Create base instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string}          fields.name - Name of instruction\n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.rs1  - First source register\n     * @param {string}          fields.rs2  - Second source register\n     * @param {number}          fields.func - Instruction function\n     */\n\tconstructor({ name, pred, rs1, rs2, func }) {\n\t\tthis.name = name;\n\t\tthis.pred = pred;\n\t\tthis.rs1 = rs1;\n\t\tthis.rs2 = rs2;\n\t\tthis.func = func; \n\t\tthis.binary = compile_reg(pred, rs1, rs2, func);\n\t}\n    \n\texecute(){\n\t\tthrow new Error(\"Missing execute handler for\", this);\n\t}\n\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rs1}, ${this.rs2}`;\n\t}\n}\nexport default Multiply;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\n\nexport const compile_reg = (pred, rs1, rs2, func) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\tfunc = parseNum(func);\n\trs1 = parseReg(rs1);\n\trs2 = parseReg(rs2);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01000 << 22;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= rs2 << 7;\n\tbinary[0] |= 0b010 << 4;\n\tbinary[0] |= func << 0;\n\n\treturn binary;\n};\n","import Multiply from \"./Multiply\";\n\n/** \n * Mul instruction class. \n * @extends Multiply\n * @category Multiply\n */\nclass Mul extends Multiply {\n\t/**\n     * Create Mul instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rs1  - First source register\n     * @param {string}          fields.rs2  - Second source register\n     */\n\tconstructor({ pred, rs1, rs2 }) {\n\t\tsuper({name: \"mul\", func: 0b0000, pred, rs1, rs2});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state       - Processor state\n     * @param {Object.<string, number>} state.reg   - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[\"s2\"] = Math.imul(reg[this.rs1], reg[this.rs2]);\n\t\treg[\"s3\"] = (reg[this.rs1] * reg[this.rs2] / (2**32)) | 0;\n\t}\n}\n\nexport default Mul;\n","import Multiply from \"./Multiply\";\n\n/** \n * Mulu instruction class. \n * @extends Multiply\n * @category Multiply\n */\nclass Mulu extends Multiply {\n\t/**\n     * Create Mulu instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rs1  - First source register\n     * @param {string}          fields.rs2  - Second source register\n     */\n\tconstructor({ pred, rs1, rs2 }) {\n\t\tsuper({name: \"mulu\", func: 0b0001, pred, rs1, rs2});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state       - Processor state\n     * @param {Object.<string, number>} state.reg   - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[\"s2\"] = Math.imul(reg[this.rs1], reg[this.rs2]);\n\t\treg[\"s3\"] = (((reg[this.rs1] >>> 0) * (reg[this.rs2] >>> 0))/(2**32))>>>0;\n\t}\n}\n\nexport default Mulu;\n","import { compile_reg } from \"./compilers\";\n\n/** \n * Represents a Predicate instruction. Sets common fields. \n */\nclass Predicate {\n\t/**\n     * Create base instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string}          fields.name - Name of instruction\n     * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {string}\t\t\tfields.pd \t- Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {string}          fields.rs2  - Second source register\n     * @param {number}          fields.func - Instruction function\n     */\n\tconstructor({ name, pred, pd, ps1, ps2, func }) {\n\t\tthis.name = name;\n\t\tthis.pred = pred;\n\t\tthis.pd = pd;\n\t\tthis.neg1 = ps1[0] === \"!\";\n\t\tthis.neg2 = ps2[0] === \"!\";\n\t\tthis.ps1 = ps1.replace(\"!\", \"\");\n\t\tthis.ps2 = ps2.replace(\"!\", \"\");\n\t\tthis.func = func; \n\t\tthis.binary = compile_reg(pred, pd, ps1, ps2, func);\n\t}\n    \n\texecute(){\n\t\tconsole.error(\"Missing execute handler for\", this);\n\t}\n\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.pd} = ${this.neg1 ? \"!\" : \"\"}${this.ps1}, ${this.neg2 ? \"!\" : \"\"}${this.ps2}`;\n\t}\n}\n\nexport default Predicate;\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\n\nexport const compile_reg = (pred, pd, ps1, ps2, func) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\tfunc = parseNum(func);\n\tpd = parseReg(pd);\n\tps1 = ps1[0] === \"!\" ? 0b1000 | parseReg(ps1) : parseReg(ps1);\n\tps2 = ps2[0] === \"!\" ? 0b1000 | parseReg(ps2) : parseReg(ps2);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01000 << 22;\n\tbinary[0] |= pd << 17;\n\tbinary[0] |= ps1 << 12;\n\tbinary[0] |= ps2 << 7;\n\tbinary[0] |= 0b100 << 4;\n\tbinary[0] |= func << 0;\n\n\treturn binary;\n};\n","import Predicate from \"./Predicate\";\n\n/** \n * Pand instruction class. \n * @extends Predicate\n * @category Predicate\n */\nclass Pand extends Predicate {\n\t/**\n     * Create Pand instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {string}\t\t\tfields.pd \t- Destination register\n     * @param {string}          fields.ps1  - First predicate register\n     * @param {string}          fields.ps2  - Second predicate register\n     */\n\tconstructor({ pred, pd, ps1, ps2 }) {\n\t\tsuper({name: \"pand\", pred, pd, ps1, ps2, func:0b0111});\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) & (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\n\t}\n}\n\nexport default Pand;\n","import Predicate from \"./Predicate\";\n\n/** \n * Pand instruction class. \n * @extends Predicate\n * @category Predicate\n */\nclass Pxor extends Predicate {\n\t/**\n     * Create Pxor instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {string}\t\t\tfields.pd \t- Destination register\n     * @param {string}          fields.ps1  - First predicate register\n     * @param {string}          fields.ps2  - Second predicate register\n     */\n\tconstructor({ pred, pd, ps1, ps2 }) {\n\t\tsuper({name: \"pxor\", pred, pd, ps1, ps2, func:0b1010});\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) ^ (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\n\t}\n}\n\nexport default Pxor;\n","import Predicate from \"./Predicate\";\n\n/** \n * Pand instruction class. \n * @extends Predicate\n * @category Predicate\n */\nclass Por extends Predicate {\n\t/**\n     * Create Por instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {string}\t\t\tfields.pd \t- Destination register\n     * @param {string}          fields.ps1  - First predicate register\n     * @param {string}          fields.ps2  - Second predicate register\n     */\n\tconstructor({ pred, pd, ps1, ps2 }) {\n\t\tsuper({name: \"por\", pred, pd, ps1, ps2, func:0b0110});\n\t}\n\t\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute( { reg } ) {\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) | (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\n\t}\n}\n\nexport default Por;\n","import { compile_reg, compile_imm } from \"./compilers\";\n\n/** \n * Represents a StackControl instruction. Sets common fields. \n */\nclass StackControl {\n\t/**\n     * Create base instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string}          fields.name - Name of instruction\n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.op   - Type of control\n\t * @param {string}          fields.s1   - Either source register or immediate value\n     */\n\tconstructor({ name, pred, op, s1 }) {\n\t\tthis.type = isNaN(s1) ? \"r\" : \"i\";\n\t\tthis.name = name;\n\t\tthis.pred = pred;\n\t\tthis.op = op;\n\t\tthis.s1 = s1;\n\n\t\tif (this.type === \"r\") {\n\t\t\tthis.binary = compile_reg(pred, op, s1);\n\t\t} else {\n\t\t\tthis.s1 &= 0x3FFFF;\n\t\t\tthis.binary = compile_imm(pred, op, s1);\n\t\t}\n\t}\n\t\n\texecute(){\n\t\tthrow new Error(\"No execute handler\");\n\t}\n\t\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.s1}`;\n\t}\n}\n\nexport default StackControl;\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\n\nexport const compile_reg = (pred, op, rs) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\top = parseNum(op);\n\trs = parseReg(rs);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01100 << 22;\n\tbinary[0] |= op << 20;\n\tbinary[0] |= 0b01 << 18;\n\tbinary[0] |= rs << 12;\n\n\treturn binary;\n};\n\nexport const compile_imm = (pred, op, imm) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\top = parseNum(op);\n\timm = parseNum(imm);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01100 << 22;\n\tbinary[0] |= op << 20;\n\tbinary[0] |= 0b00 << 18;\n\tbinary[0] |= imm << 0;\n\n\treturn binary;\n};\n\n","import StackControl from \"./StackControl\";\n\n/** \n * Sres instruction class. \n * @extends StackControl\n * @category StackControl\n */\nclass Sens extends StackControl {\n\t/**\n     * Create Sens instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \n     */\n\tconstructor({ pred, s1 }) {\n\t\tsuper({name: \"sens\", pred, op: 0b01, s1});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\tlet n = Number(this.type === \"r\" ? reg[this.s1] : this.s1 << 2); // Word size to byte size\n\t\treg[\"s5\"] = Math.max(reg[\"s5\"], reg[\"s6\"] + n);\n        \n\t\t/*\n        let nfill;\n        nfill = n - (reg[\"s5\"] - reg[\"s6\"]); // n - (m_top - sc_top)\n        for (let i = 0; i < nfill; ++i){\n            // We aren't actually implementing a stack cache and thus no copying is needed.\n            //sc[reg[\"s5\"]] = gm[reg[\"s5\"]];\n            reg[\"s5\"] += 1;\n        }\n        */\n\t}\n}\n\nexport default Sens;\n","import StackControl from \"./StackControl\";\n\n/** \n * Sfree instruction class. \n * @extends StackControl\n * @category StackControl\n */\nclass Sfree extends StackControl {\n\t/**\n     * Create Sfree instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \n     */\n\tconstructor({ pred, s1 }) {\n\t\tsuper({name: \"sfree\", pred, op: 0b10, s1});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\t// Increment st by n words.\n\t\treg[\"s6\"] += Number(this.s1) << 2;\n\t\t// If st > ss, set ss = st\n\t\tif(reg[\"s6\"] > reg[\"s5\"]){\n\t\t\treg[\"s5\"] = reg[\"s6\"];\n\t\t}\n\t}\n}\n\nexport default Sfree;\n","import StackControl from \"./StackControl\";\n\n/** \n * Sres instruction class. \n * @extends StackControl\n * @category StackControl\n */\nclass Sres extends StackControl {\n\t/**\n     * Create Sres instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.s1   - Immediate value\n     */\n\tconstructor({ pred, s1 }) {\n\t\tsuper({name: \"sres\", pred, op: 0b00, s1});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg/*, sc*/ }) {\n\t\t//let nspill;\n\t\treg[\"s6\"] -= Number(this.s1) << 2; // Words to bytes.\n\t\t/*nspill = reg[\"s5\"] - reg[\"s6\"]; //- sc[\"MAX_SIZE\"]; // max_size of our imaginary cache as 0 would be boring :)\n\t\tfor(let i = 0; i < nspill; ++i){\n\t\t\treg[\"s5\"] -= 1;\n\t\t\t// Copying not needed as we have no actual cache.\n\t\t\t//gm[reg[\"s5\"]] = sc[reg[\"s5\"]]; // No masking, just keep the keys identical between sc and gm.\n\t\t}*/\n\t}\n}\n\nexport default Sres;\n","import StackControl from \"./StackControl\";\n\n/** \n * Sspill instruction class. \n * @extends StackControl\n * @category StackControl\n */\nclass Sspill extends StackControl {\n\t/**\n     * Create Sspill instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string|number}   fields.pred - Instruction predicate\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \n     */\n\tconstructor({ pred, s1 }) {\n\t\tsuper({name: \"sspill\", pred, op: 0b11, s1});\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg  }) {\n\t\tlet n = Number(this.type === \"r\" ? reg[this.s1] : this.s1 << 2);\n\t\treg[\"s5\"] -= n;\n\t\t// not emulating the actual spill from cache to mem.\n\t}\n}\n\nexport default Sspill;\n","import {compile_reg} from \"./compilers\";\nimport { toUint32 } from \"../../../Helpers/misc\";\n\n/** \n * Represents a StoreTyped instruction. Sets common fields. \n */\nclass StoreTyped {\n\t/**\n     * Create base instruction.\n     * @param {Object}          fields      - Fields to set \n     * @param {string}          fields.name - Name of instruction\n     * @param {string|number}   fields.pred - Instruction predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {number}   \t\tfields.imm  - Immediate offset value\n     */\n\tconstructor({ name, pred, type, ra, rs, imm }) {\n\t\tthis.name = name;\n\t\tthis.pred = pred;\n\t\tthis.type = type;\n\t\tthis.ra = ra;\n\t\tthis.rs = rs;\n\t\tthis.imm = toUint32(imm) & 0x7F;\n\t\tthis.binary = compile_reg(pred, type, ra, rs, imm);\n\t}\n\n\texecute() {\n\t\tthrow new Error(\"Missing execute handler for\", this);\n\t}\n\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} [${this.ra} + ${this.imm}] = ${this.rs}`;\n\t}\n}\n\nexport default StoreTyped;\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\n\nexport const compile_reg = (pred, type, ra, rs, offset) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\ttype = parseNum(type);\n\tra = parseReg(ra);\n\trs = parseReg(rs);\n\toffset = parseNum(offset);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01011 << 22;\n\tbinary[0] |= type << 17;\n\tbinary[0] |= ra << 12;\n\tbinary[0] |= rs << 7;\n\tbinary[0] |= offset << 0;\n\n\treturn binary;\n};\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Sbc instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Sbc extends StoreTyped {\n\t/**\n     * Create Sbc instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"sbc\", pred, type: 0b01010, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm);\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Sbc;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Sbl instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Sbl extends StoreTyped {\n\t/**\n     * Create Sbl instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"sbl\", pred, type: 0b01001, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm);\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Sbl;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Sbm instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Sbm extends StoreTyped {\n\t/**\n     * Create Sbm instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"sbm\", pred, type: 0b01011, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm);\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Sbm;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Sbs instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Sbs extends StoreTyped {\n\t/**\n     * Create Sbs instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"sbs\", pred, type: 0b01000, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm);\n\t\tmem[addr]   = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Sbs;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Shc instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Shc extends StoreTyped {\n\t/**\n     * Create Shc instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"shc\", pred, type: 0b00110, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Shc;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Shl instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Shl extends StoreTyped {\n\t/**\n     * Create Shl instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"shl\", pred, type: 0b00101, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Shl;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Shm instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Shm extends StoreTyped {\n\t/**\n     * Create Shm instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"shm\", pred, type: 0b00111, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Shm;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Shs instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Shs extends StoreTyped {\n\t/**\n     * Create Shs instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"shs\", pred, type: 0b00100, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm << 1);\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Shs;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Swc instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Swc extends StoreTyped {\n\t/**\n     * Create Swc instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"swc\", pred, type: 0b00010, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Swc;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Swl instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Swl extends StoreTyped {\n\t/**\n     * Create Swl instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"swl\", pred, type: 0b00001, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Swl;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Swm instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Swm extends StoreTyped {\n\t/**\n     * Create Swm instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"swm\", pred, type: 0b00011, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Swm;\n","import StoreTyped from \"./StoreTyped\";\n\n/** \n * Sws instruction class. \n * @extends StoreTyped\n * @category StoreTyped\n */\nclass Sws extends StoreTyped {\n\t/**\n     * Create Sws instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.ra   - Destination\n     * @param {string}          fields.rs  \t- Source register\n     * @param {string|number}   fields.imm  - Immediate offset value\n     */\n\tconstructor({ pred, ra, rs, imm }) {\n\t\tsuper({name: \"sws\", pred, type: 0b00000, ra, rs, imm});\n\t}\n\n\t/**\t\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg, mem }) {\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm << 2);\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\n\t}\n}\n\nexport default Sws;\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\n\nexport const compile_reg = (pred, rd, rs1, imm, ps) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\timm = parseNum(imm);\n\trd = parseReg(rd);\n\trs1 = parseReg(rs1);\n\tps = ps[0] === \"!\" ? 0b1000 | parseReg(ps) : parseReg(ps);\n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01000 << 22;\n\tbinary[0] |= rd << 17;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= imm << 7;\n\tbinary[0] |= 0b101 << 4;\n\tbinary[0] |= ps << 0;\n\n\treturn binary;\n};\n\n/** \n * Bitcopy instruction class. \n * @category Bitcopy\n */\nclass Bcopy {\n\t/**\n     * Create Bcopy instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n     * @param {string}          fields.rs1  - First source register\n     * @param {number}          fields.imm  - Second operand, immediate value.\n     * @param {string}          fields.ps   - Predicate register. (can be negated)\n     */\n\tconstructor({pred, rd, rs1, imm, ps}) {\n\t\tthis.name = \"bcopy\";\n\t\tthis.pred = pred;\n\t\tthis.rd = rd;\n\t\tthis.rs1 = rs1;\n\t\tthis.imm = imm & 0x1F;\n\t\tthis.ps = ps; \n\t\tthis.binary = compile_reg(pred, rd, rs1, imm, ps); \n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\tlet shift = (this.ps[0] === \"!\") === (reg[this.ps.replace(\"!\",\"\")] === 1) ? 0 : 1; // Handle negation of p-register\n\t\treg[this.rd] = (reg[this.rs1] & ~(1 << this.imm)) | (shift << this.imm);\n\t}\n\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.rs1}, ${this.imm}, ${this.ps}`;\n\t}\n\n}\n\nexport default Bcopy;\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\n\nexport const compile_reg = (pred, rd, ss) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\trd = parseReg(rd);\n\tss = parseReg(ss); \n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01001 << 22;\n\tbinary[0] |= rd << 17;\n\tbinary[0] |= 0b011 << 4;\n\tbinary[0] |= ss << 0;\n\n\treturn binary;\n};\n\n/** \n * Move from special instruction class. \n * @category MoveFromSpecial\n */\nclass Mfs {\n\t/**\n     * Create Mfs instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rd   - Destination register\n\t * @param {string}\t\t\tfields.ss\t- Special source register\n     */\n\tconstructor({pred, rd, ss}) {\n\t\tthis.name = \"mfs\";\n\t\tthis.pred = pred;\n\t\tthis.rd = rd;\n\t\tthis.ss = ss;\n\t\tthis.binary = compile_reg(pred, rd, ss);\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.rd] = reg[this.ss];\n\t}\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.ss}`;\n\t}\n}\n\nexport default Mfs;\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\n\nconst compile_reg = (pred, rs1, sd) => {\n\tlet binary = [0];\n\n\tpred = parseNum(pred);\n\trs1 = parseReg(rs1);\n\tsd = parseReg(sd); \n\n\tbinary[0] |= pred << 27;\n\tbinary[0] |= 0b01001 << 22;\n\tbinary[0] |= rs1 << 12;\n\tbinary[0] |= 0b010 << 4;\n\tbinary[0] |= sd << 0;\n\n\treturn binary;\n};\n\n/** \n * Move to special instruction class. \n * @category MoveToSpecial\n */\nclass Mts {\n\t/**\n     * Create Mts instruction.\n     * @param {Object}          fields      - Fields to set\n     * @param {string|number}   fields.pred - Predicate\n     * @param {string}          fields.rs1  - Source register\n     * @param {string}          fields.sd   - Special destination register\n     */\n\tconstructor({pred, rs1, sd}) {\n\t\tthis.name = \"mts\";\n\t\tthis.pred = pred;\n\t\tthis.rs1 = rs1;\n\t\tthis.sd = sd;\n\t\tthis.binary = compile_reg(pred, rs1, sd);\n\t}\n\n\t/**\n     * Executes the instruction\n     * @param {Object}                  state        - Processor state\n     * @param {Object.<string, number>} state.reg    - Registers\n     */\n\texecute({ reg }) {\n\t\treg[this.sd] = reg[this.rs1];\n\t\tif(this.sd === \"s0\"){\n\t\t\treg[this.sd] &= 0xFF;\n\t\t\treg[\"p0\"] = 1;\n\t\t\treg[\"p1\"] = reg[\"s0\"] >> 1;\n\t\t\treg[\"p2\"] = reg[\"s0\"] >> 2;\n\t\t\treg[\"p3\"] = reg[\"s0\"] >> 3;\n\t\t\treg[\"p4\"] = reg[\"s0\"] >> 4;\n\t\t\treg[\"p5\"] = reg[\"s0\"] >> 5;\n\t\t\treg[\"p6\"] = reg[\"s0\"] >> 6;\n\t\t\treg[\"p7\"] = reg[\"s0\"] >> 7;\n\t\t}\n\t}\n\ttoString(){\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.sd} = ${this.rs1}`;\n\t}\n}\n\nexport default Mts;\n","import { getInstType } from \"./typeStrings\";\n\n// All instruction regular expressions\nconst regEx = {\n\t// Label, pred, type\n\t\"first\" : [/^(?!#)(?:(\\w+):\\s*)?(?:\\((!?)(p\\d)\\)\\s+)?(\\w+)\\s*/i,\t\t\t\t\t\t\"label: (ps) type\"],\n\n\t// Normal instructions (new)\n\t\"bin\" \t: [/^(r\\d{1,2})\\s*=\\s*(r\\d{1,2})\\s*,\\s*\\(?([^()\\s]+)\\)?$/i, \t\t\t\t\t\t\t\t\"rd = rs1, op2\"],\n\t\"comp\"\t: [/^(p\\d)\\s*=\\s*(r\\d{1,2})\\s*,\\s*(r?(?:0x)?(?:0b)?\\d+)$/i,\t\t\t\t\t\t\"pd = rs1, op2\"],\n\t\"load\"\t: [/^(r\\d{1,2})\\s*=\\s*\\[(r\\d{1,2})\\s*\\+\\s*(\\w+)\\]$/i,  \t\t\t\t\t\t\t\"rd = [rs + imm]\"],\n\t\"store\"\t: [/^\\[(r\\d{1,2})\\s*\\+\\s*((?:0x)?(?:0b)?\\d+)\\]\\s*=\\s*(r\\d{1,2})$/i,\t\t\t\t\"[rd + imm] = rs\"],\n\t\"mul\"\t: [/^(r\\d{1,2})\\s*,\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\t\"rs1, rs2\"],\n\t\"stack\"\t: [/^(r?(?:0x)?(?:0b)?\\d+)\\s?$/i,\t\t\t\t\t\t\t\t\t\t\t\t\"op2\"],\n\t\"pred\"\t: [/^(p\\d)\\s*=\\s*(!?p\\d)\\s*,\\s*(!?p\\d)$/i,\t\t\t\t\t\t\t\t\t\t\"pd = ps1, ps2\"],\n\t\"cf\"\t: [/^\\s*(-?\\w*),?\\s*(\\w*)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"label\"],\n\t\"mts\"\t: [/^(sro|srb|sxo|sxb|sl|sh|ss|st|s\\d{1,2})\\s*=\\s*(r\\d{1,2})$/i,\t\t\t\t\"sd = rs\"],\n\t\"mfs\"\t: [/^(r\\d{1,2})\\s*=\\s*(sro|srb|sxo|sxb|sl|sh|ss|st|s\\d{1,2})$/i,\t\t\t\t\"rd = ss\"],\t\t\n\t\"bcopy\"\t: [/^(r\\d{1,2})\\s*=\\s*(r\\d{1,2}),\\s*((?:0x)?(?:0b)?\\d+),\\s*(!?p\\d)$/i,\t\"rd = rs, imm, [!]ps\"],\n\n\t// Pseudo instructions\n\t\"mov\"\t: [/^(r\\d{1,2})\\s*=\\s*(r\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\t\"rd = rs\"],\n\t\"pmov\"\t: [/^(p\\d)\\s*=\\s*(p\\d)$/i, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = ps\"],\n\t\"isodd\"\t: [/^(p\\d)\\s*=\\s*(r\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\t\t\"pd = rs\"],\n\t\"clr\"\t: [/^([rp]\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rd/pd\"],\n\t\"neg\"\t: [/^(r\\d{1,2})\\s*=\\s*-\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\"rd = -rs\"],\n\t\"not\"\t: [/^(r\\d{1,2})\\s*=\\s*!\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\"rd = !rs\"],\n\t\"li\"\t: [/^(r\\d{1,2})\\s*=\\s*(\\(?([^()\\s]+)\\)?)$/i,\t\t\t\t\t\t\t\t\t\"rd = imm\"],\n\t\"nop\" \t: [/^\\s*$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"nop\"],\n\t\"pset\"\t: [/^(p\\d)\\s*=\\s*1$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = 1\"],\n\t\"pnot\"\t: [/^(p\\d)\\s*=\\s*!\\s*(p\\d)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = !ps\"],\n\t\"pclr\"\t: [/^(p\\d)\\s*=\\s*(0)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = 0\"],\n};\n\n/**\n * Gets regular expression from type\n * @param {string} \ttype  - Instruction type\n * @returns a regular expression\n */\nconst getRegEx = (type) => {\n\tif (regEx[getInstType(type)] === undefined) {return -1; }\n\treturn regEx[getInstType(type)][0];\n};\n\nconst getRegExError = (type) => {\n\tif (regEx[getInstType(type)] === undefined) {return -1; }\n\treturn `Instruction ${type} should be on form: ${regEx[getInstType(type)][1]}`;\n};\n\nexport { getRegEx, getRegExError };\n","import { Add, Sub, Xor, Nor, ShiftLeft, ShiftRight, Or, And, ShiftRightArithmetic, ShiftAdd, ShiftAdd2 } from \"../Instructions/Binary Arithmetics/index\";\nimport { Btest, Cmpeq, Cmple, Cmplt, Cmpneq, Cmpule, Cmpult } from \"../Instructions/Compare/index\";\nimport { Br, Brcf, Brcfnd, Brnd, Call, Callnd, Ret, Retnd, Trap, Xret, Xretnd } from \"../Instructions/Control Flow/index\";\nimport { Lws, Lwl, Lwc, Lwm, Lhs, Lhl, Lhc, Lhm, Lbs, Lbl, Lbc, Lbm, Lhus, Lhul, Lhuc, Lhum, Lbus, Lbul, Lbuc, Lbum } from \"../Instructions/Load Typed/index\";\nimport { Mul, Mulu } from \"../Instructions/Multiply/index\";\nimport { Pand, Pxor, Por } from \"../Instructions/Predicate/index\";\nimport { Sens, Sfree, Sres, Sspill } from \"../Instructions/Stack Control/index\";\nimport { Sbc, Sbl, Sbm, Sbs, Shc, Shl, Shm, Shs, Swc, Swl, Swm, Sws } from \"../Instructions/Store Typed/index\";\nimport Bcopy from \"../Instructions/Bcopy\";\nimport Mfs from \"../Instructions/Mfs\";\nimport Mts from \"../Instructions/Mts\";\nimport { instTypes, binTypes, allowedPipelineTwo, pseudoTypes, pseudoMapping, cfTypes, loadTypes } from \"../../Helpers/typeStrings\";\nimport { regStr, allRegStr, sregMap } from \"../../Helpers/regStrings\";\nimport { getRegEx, getRegExError } from \"../../Helpers/regEx\";\n\nclass Assembler {\n\tconstructor() {\n\t\tthis.bundles = [];\n\t\tthis.labels = {};\n\t\tthis.offset = 0;\n\t\tthis.error = [];\n\t\tthis.numMap = [];\n\t}\n\n\treset() {\n\t\tthis.bundles = [];\n\t\tthis.labels = {};\n\t\tthis.offset = 0;\n\t\tthis.error = [];\n\t\tthis.numMap = [];\n\t}\n\n\t// should add debouncing :)\n\trun(editor) {\n\t\tthis.reset();\n\t\tlet input = this.cleanInput(editor);\n\t\tfor (let line of input)\n\t\t\tthis.parse(line);\n\t\tfor (let bundle of this.bundles) {\n\t\t\tif(this.resolveOperands(bundle))\n\t\t\t\tthis.compileBundle(bundle);\n\t\t}\n\t\treturn this.checkErr();\n\t}\n\n\t// if no errors, erase error array\n\tcheckErr() {\n\t\tfor (let key in this.error)\n\t\t\tif (this.error[key] !== \"fine\") return false;\n\t\tthis.error = [];\n\t\treturn true;\n\t}\n\n\tparse(line) {\n\t\tif(/^\\s*$/i.test(line)) return true;\n\t\tlet insts = line.split(\"||\");\n\t\tlet bundle = { is_data: false, data: null, offset: this.offset, instructions: [], size: 0 };\n\t\tlet idx = this.bundles.push(bundle) - 1;\n\t\t\n\t\t/* Perhaps change to is_data and and different regex for .word, .string etc. */\n\t\t//Figure out how to handle base and pc when a .word n+4 is injected into the asm as that indicates a code block that is n bytes...\n\t\tlet is_word = line.match(/^(?:(\\w+):)?(?:\\s+)?\\.word\\s+([^\\s]+)$/i);\n\t\tif(is_word) {\n\t\t\tbundle.is_data = true;\n\t\t\tbundle.data = {type: \"word\", value: is_word[2]};\n\t\t\tif(is_word[1]) this.labels[is_word[1]] = idx;\n\t\t\tthis.offset += 4;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (insts.length > 2) {\n\t\t\tthis.error[idx] = \"Only two instructions per bundle allowed!\";\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\tfor (let j in insts) {\n\t\t\tlet inst = insts[j];\n\t\t\tinst = inst.trim();\n\t\t\t\n\t\t\t// Get instruction match\n\t\t\tlet match = inst.match(getRegEx(\"first\"));\n\t\t\tif (!match) { \n\t\t\t\tthis.error[idx] = getRegExError(\"first\"); \n\t\t\t\treturn false; \n\t\t\t}\n\t\t\tlet label = match[1];\n\t\t\tlet neg = match[2] === \"!\";\n\t\t\tlet pred = match[3] ? Number(match[3].toLowerCase().replace(\"p\", \"\")) : 0;\n\t\t\tlet type = match[4].toLowerCase();\n\t\t\tif (type === \"halt\") type = \"nop\";\n\t\t\tmatch = inst.replace(match[0], \"\").match(getRegEx(type));\n\t\t\t\n\t\t\t// Check if inst is a proper instruction\n\t\t\tif (!instTypes.includes(type)) {\n\t\t\t\tthis.error[idx] = `${type} is not an instruction`;\n\t\t\t\treturn false; \n\t\t\t} else if (!match){\n\t\t\t\tthis.error[idx] = getRegExError(type); \n\t\t\t\treturn false; \n\t\t\t}\n\n\t\t\t// Re-write pseudo instruction into its corresponding instruction\n\t\t\tif (pseudoTypes.includes(type)) {\n\t\t\t\tlet ptype = type.toUpperCase();\n\t\t\t\tswitch (ptype) {\n\t\t\t\t\tcase \"LI\":\n\t\t\t\t\t\tif (Number(match[2] < 0)) {\n\t\t\t\t\t\t\tptype = \"LI_NEG\";\n\t\t\t\t\t\t\tmatch[2] = -match[2];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tptype = \"LI_POS\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"MOV\":\n\t\t\t\t\t\tptype += (regStr.includes(match[1])) ? \"_R\" : \"_P\";\n\t\t\t\t\t\tptype += (regStr.includes(match[2])) ? \"R\" : \"P\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: break;\n\t\t\t\t}\n\n\t\t\t\t// Get the original instruction and get its match\n\t\t\t\tlet basic = pseudoMapping[ptype].replace(/{(\\d+)}/g, (_, n) => match[n]);\n\t\t\t\tmatch = basic.match(getRegEx(\"first\"));\n\t\t\t\ttype = match[4].toLowerCase();\n\t\t\t\tmatch = basic.replace(match[0], \"\").match(getRegEx(type));\n\t\t\t}\n\n\t\t\t// Define the instruction\n\t\t\tlet i = { pred: { p: pred, n: neg }, type, ops: match.slice(1), original: inst.replace(/\\s+/gi, \" \") };\n\t\t\tlet is_long_imm = (binTypes.includes(type) && Number(i.ops[2]) && ((Number(i.ops[2]) > 0xFFF) || [\"nor\", \"shadd\", \"shadd2\"].includes(type)));\n\t\t\t\n\t\t\t// Check if pipelined/bundled correctly\n\t\t\tif (insts.length === 2) {\n\t\t\t\tif (is_long_imm) {\n\t\t\t\t\tthis.error[idx] = \"Can't bundle a 64-bit instruction with anything else\";\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (j === 1 && !allowedPipelineTwo(type)) {\n\t\t\t\t\tthis.error[idx] = `${type} can't run in pipeline two.`;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (label) this.labels[label] = idx;\n\t\t\tbundle.instructions.push(i);\n\t\t\tbundle[\"size\"] += is_long_imm ? 8 : 4;\n\t\t}\n\t\tthis.offset += bundle[\"size\"];\n\t\treturn true;\n\t}\n\n\tresolveOperands(bundle) {\n\t\tlet idx = bundle.offset/4;\n\n\t\tif(bundle.is_data){\n\t\t\tlet multi = bundle.data.value.match(/^(\\S+)([+-])(\\S+)$/i);\n\t\t\t\n\t\t\tif (Object.keys(this.labels).includes(bundle.data.value)){\n\t\t\t\tbundle.data.value = this.bundles[this.labels[bundle.data.value]].offset;\n\t\t\t} else if (multi && Object.keys(this.labels).includes(multi[1]) && Object.keys(this.labels).includes(multi[3])){\n\t\t\t\tlet t1 = this.bundles[this.labels[multi[1]]].offset;\n\t\t\t\tlet t2 = this.bundles[this.labels[multi[3]]].offset;\n\t\t\t\tbundle.data.value = multi[2] === \"+\" ? t1 + t2: t1 - t2 ;\n\t\t\t} else {\n\t\t\t\tbundle.data.value = Number(bundle.data.value);\n\t\t\t}\n\t\t}\n\n\t\tfor (let instruction of bundle.instructions) {\n\t\t\tfor (let i in instruction.ops) {\n\t\t\t\tlet op = instruction.ops[i];\n\t\t\t\tlet op_lc = op.toLowerCase();\n\t\t\t\tlet multi = op.match(/^(\\S+)([+-])(\\S+)$/i);\n\t\t\t\tif (sregMap[op_lc]) {\n\t\t\t\t\tinstruction.ops[i] = sregMap[op_lc];\n\t\t\t\t} else if (allRegStr.includes(op_lc)) {\n\t\t\t\t\tinstruction.ops[i] = op_lc;\n\t\t\t\t} else if (Object.keys(this.labels).includes(op) || (multi && Object.keys(this.labels).includes(multi[1]) && Object.keys(this.labels).includes(multi[3]))) {\n\t\t\t\t\tlet target;\n\t\t\t\t\tif(multi){\n\t\t\t\t\t\tlet t1 = this.bundles[this.labels[multi[1]]].offset;\n\t\t\t\t\t\tlet t2 = this.bundles[this.labels[multi[3]]].offset;\n\t\t\t\t\t\ttarget = multi[2] === \"+\" ? t1 + t2: t1 - t2 ;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget = this.bundles[this.labels[op]].offset;\n\t\t\t\t\t}\n\t\t\t\t\tif(cfTypes.includes(instruction.type)){\n\t\t\t\t\t\tif([\"br\", \"brnd\"].includes(instruction.type)){\n\t\t\t\t\t\t\tinstruction.ops[i] = String((target-bundle.offset) >> 2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinstruction.ops[i] = String(target >> 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(loadTypes.includes(instruction.type)){\n\t\t\t\t\t\tlet shift = 0;\n\t\t\t\t\t\tif(instruction.type.includes(\"w\"))\n\t\t\t\t\t\t\tshift = 2;\n\t\t\t\t\t\telse if(instruction.type.includes(\"h\"))\n\t\t\t\t\t\t\tshift = 1;\n\t\t\t\t\t\tinstruction.ops[i] = String(target >> shift);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tinstruction.ops[i] = String(target);\n\t\t\t\t\t}\n\t\t\t\t} else if (isNaN(op)) {\n\t\t\t\t\tthis.error[idx] = \"Can't resolve operands\";\n\t\t\t\t\treturn false;\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Removes empty lines and comments\n\t * @param \t{string} \teditor \t\t- User input editor \n\t * @returns {array}\t\toutput\t\t- Array of lines that are not empty or comments\n\t */\n\tcleanInput = (editor) => {\n\t\tlet lines = editor.replace(/~/gi, \"!\").split(/(?:\\r?\\n)/);\n\t\tlet output = [];\n\t\tfor (let i = 0; i < lines.length; ++i) {\n\t\t\tlet line = lines[i].split(\"#\", 1)[0].trim(); // Remove comments\n\t\t\tlet insts = line.split(\";\");\n\t\t\tfor (let j = 0; j < insts.length; ++j){\n\t\t\t\tlet only_label = insts[j].match(/^\\w+:$/);\n\t\t\t\tif (line) {\n\t\t\t\t\tif (only_label && i + 1 < lines.length) {\n\t\t\t\t\t\tlines[i + 1] = only_label[0] + \" \" + lines[i + 1];\n\t\t\t\t\t} else if (!only_label && insts[j]) {\n\t\t\t\t\t\toutput.push(insts[j]);\n\t\t\t\t\t}\n\t\t\t\t\tthis.numMap[output.length-1] = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t};\n\t\n\t/**\n\t * compileBundle creates a new instance of an instruction class for every instruction in\n\t * the input bundle (one or two instructions). Also sets the binary field of the Object\n\t * @param {*} bundle - One or two instructions.\n\t */\n\tcompileBundle(bundle) {\n\t\tfor (let i in bundle.instructions) {\n\t\t\tlet cInst;\n\t\t\tlet { pred, type, ops } = bundle.instructions[i];\n\t\t\tlet predicate = pred.p | (pred.n << 3);\n\n\t\t\tlet BinaryInst \t= { pred: predicate, rd:  ops[0], rs1: ops[1], op2: ops[2] };\n\t\t\tlet CompareInst = { pred: predicate, pd:  ops[0], rs1: ops[1], op2: ops[2] };\n\t\t\tlet ControlInst = { pred: predicate, s1:  ops[0], s2 : ops[1] };\n\t\t\tlet LoadInst \t= { pred: predicate, rd:  ops[0], ra:  ops[1], imm: ops[2] };\n\t\t\tlet MulInst \t= { pred: predicate, rs1: ops[0], rs2: ops[1] };\n\t\t\tlet PredInst \t= { pred: predicate, pd:  ops[0], ps1: ops[1], ps2: ops[2] };\n\t\t\tlet StackInst \t= { pred: predicate, s1:  ops[0] };\n\t\t\tlet StoreInst \t= { pred: predicate, ra:  ops[0], imm: ops[1], rs:  ops[2] };\n\t\t\tlet BcopyInst \t= { pred: predicate, rd:  ops[0], rs1: ops[1], imm: ops[2], ps: ops[3] };\n\n\t\t\t// Pick inst from its name/type\n\t\t\tswitch (type) {\n\t\t\t\t// BinaryArithmetics\n\t\t\t\tcase \"add\":\n\t\t\t\tcase \"addi\":\n\t\t\t\tcase \"addl\":\n\t\t\t\t\tcInst = new Add(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sub\":\n\t\t\t\tcase \"subi\":\n\t\t\t\tcase \"subl\":\n\t\t\t\t\tcInst = new Sub(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"or\":\n\t\t\t\tcase \"ori\":\n\t\t\t\tcase \"orl\":\n\t\t\t\t\tcInst = new Or(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"and\":\n\t\t\t\tcase \"andi\":\n\t\t\t\tcase \"andl\":\n\t\t\t\t\tcInst = new And(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"xor\":\n\t\t\t\tcase \"xori\":\n\t\t\t\tcase \"xorl\":\n\t\t\t\t\tcInst = new Xor(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"nor\":\n\t\t\t\tcase \"norl\":\n\t\t\t\t\tcInst = new Nor(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sl\":\n\t\t\t\tcase \"sli\":\n\t\t\t\tcase \"sll\":\n\t\t\t\t\tcInst = new ShiftLeft(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sr\":\n\t\t\t\tcase \"sri\":\n\t\t\t\tcase \"srl\":\n\t\t\t\t\tcInst = new ShiftRight(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sra\":\n\t\t\t\tcase \"srai\":\n\t\t\t\tcase \"sral\":\n\t\t\t\t\tcInst = new ShiftRightArithmetic(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"shadd\":\n\t\t\t\t\tcInst = new ShiftAdd(BinaryInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"shadd2\":\n\t\t\t\t\tcInst = new ShiftAdd2(BinaryInst);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Compare\n\t\t\t\tcase \"btest\":\n\t\t\t\tcase \"btesti\":\n\t\t\t\t\tcInst = new Btest(CompareInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"cmpeq\":\n\t\t\t\tcase \"cmpieq\":\n\t\t\t\t\tcInst = new Cmpeq(CompareInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"cmple\":\n\t\t\t\tcase \"cmpile\":\n\t\t\t\t\tcInst = new Cmple(CompareInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"cmplt\":\n\t\t\t\tcase \"cmpilt\":\n\t\t\t\t\tcInst = new Cmplt(CompareInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"cmpneq\":\n\t\t\t\tcase \"cmpineq\":\n\t\t\t\t\tcInst = new Cmpneq(CompareInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"cmpule\":\n\t\t\t\tcase \"cmpiule\":\n\t\t\t\t\tcInst = new Cmpule(CompareInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"cmpult\":\n\t\t\t\tcase \"cmpiult\":\n\t\t\t\t\tcInst = new Cmpult(CompareInst);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LoadType \n\t\t\t\tcase \"lbc\":\n\t\t\t\t\tcInst = new Lbc(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lbl\":\n\t\t\t\t\tcInst = new Lbl(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lbm\":\n\t\t\t\t\tcInst = new Lbm(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lbs\":\n\t\t\t\t\tcInst = new Lbs(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lbuc\":\n\t\t\t\t\tcInst = new Lbuc(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lbul\":\n\t\t\t\t\tcInst = new Lbul(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lbum\":\n\t\t\t\t\tcInst = new Lbum(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lbus\":\n\t\t\t\t\tcInst = new Lbus(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lhc\":\n\t\t\t\t\tcInst = new Lhc(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lhl\":\n\t\t\t\t\tcInst = new Lhl(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lhm\":\n\t\t\t\t\tcInst = new Lhm(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lhs\":\n\t\t\t\t\tcInst = new Lhs(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lhuc\":\n\t\t\t\t\tcInst = new Lhuc(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lhul\":\n\t\t\t\t\tcInst = new Lhul(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lhum\":\n\t\t\t\t\tcInst = new Lhum(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lhus\":\n\t\t\t\t\tcInst = new Lhus(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lwc\":\n\t\t\t\t\tcInst = new Lwc(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lwl\":\n\t\t\t\t\tcInst = new Lwl(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lwm\":\n\t\t\t\t\tcInst = new Lwm(LoadInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"lws\":\n\t\t\t\t\tcInst = new Lws(LoadInst);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Multiply \n\t\t\t\tcase \"mul\":\n\t\t\t\t\tcInst = new Mul(MulInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"mulu\":\n\t\t\t\t\tcInst = new Mulu(MulInst);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Predicate\n\t\t\t\tcase \"pand\":\n\t\t\t\t\tcInst = new Pand(PredInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"por\":\n\t\t\t\t\tcInst = new Por(PredInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pxor\":\n\t\t\t\t\tcInst = new Pxor(PredInst);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// StoreTyped\n\t\t\t\tcase \"sbc\":\n\t\t\t\t\tcInst = new Sbc(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sbl\":\n\t\t\t\t\tcInst = new Sbl(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sbm\":\n\t\t\t\t\tcInst = new Sbm(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sbs\":\n\t\t\t\t\tcInst = new Sbs(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"shc\":\n\t\t\t\t\tcInst = new Shc(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"shl\":\n\t\t\t\t\tcInst = new Shl(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"shm\":\n\t\t\t\t\tcInst = new Shm(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"shs\":\n\t\t\t\t\tcInst = new Shs(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"swc\":\n\t\t\t\t\tcInst = new Swc(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"swl\":\n\t\t\t\t\tcInst = new Swl(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"swm\":\n\t\t\t\t\tcInst = new Swm(StoreInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sws\":\n\t\t\t\t\tcInst = new Sws(StoreInst);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Stack Control\n\t\t\t\tcase \"sens\":\n\t\t\t\tcase \"sensr\":\n\t\t\t\t\tcInst = new Sens(StackInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sfree\":\n\t\t\t\t\tcInst = new Sfree(StackInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sres\":\n\t\t\t\t\tcInst = new Sres(StackInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sspill\":\n\t\t\t\tcase \"sspillr\":\n\t\t\t\t\tcInst = new Sspill(StackInst);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Control Flow \n\t\t\t\tcase \"br\":\n\t\t\t\tcase \"brr\":\n\t\t\t\t\tcInst = new Br(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"brcf\":\n\t\t\t\tcase \"brcfr\":\n\t\t\t\t\tcInst = new Brcf(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"brcfnd\":\n\t\t\t\tcase \"brcfndr\":\n\t\t\t\t\tcInst = new Brcfnd(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"brnd\":\n\t\t\t\tcase \"brndr\":\n\t\t\t\t\tcInst = new Brnd(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"call\":\n\t\t\t\tcase \"callr\":\n\t\t\t\t\tcInst = new Call(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"callnd\":\n\t\t\t\tcase \"callndr\":\n\t\t\t\t\tcInst = new Callnd(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ret\":\n\t\t\t\t\tcInst = new Ret(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"retnd\":\n\t\t\t\t\tcInst = new Retnd(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"trap\":\n\t\t\t\t\tcInst = new Trap(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"xret\":\n\t\t\t\t\tcInst = new Xret(ControlInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"xretnd\":\n\t\t\t\t\tcInst = new Xretnd(ControlInst);\n\t\t\t\t\tbreak; \n\n\t\t\t\t// Rest\n\t\t\t\tcase \"bcopy\":\n\t\t\t\t\tcInst = new Bcopy(BcopyInst);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"mfs\":\n\t\t\t\t\tcInst = new Mfs({ pred: pred.p | (pred.n << 3), rd: ops[0], ss: ops[1] });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"mts\":\n\t\t\t\t\tcInst = new Mts({ pred: pred.p | (pred.n << 3), rs1: ops[1], sd: ops[0] });\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Not implemented\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(`Instruction ${type} not implemented.`);\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (bundle.instructions[i].original === \"halt\") {\n\t\t\t\tcInst.binary[0] = 0x05400000;\n\t\t\t\tcInst.toString = () => {return \"\"; };\n\t\t\t}\n\t\t\tif (Number(i) === 0 && bundle.instructions.length === 2) {\n\t\t\t\tcInst.binary[0] |= 1 << 31;\n\t\t\t}\n\t\t\tbundle.instructions[i].instruction = cInst;\n\n\t\t\tlet idx = bundle.offset/4;\n\t\t\tif (!this.error[idx]) this.error[idx] = \"fine\";\n\t\t}\n\t}\n}\nexport default Assembler;\n","import React, { Component } from \"react\";\nimport FrontEnd from \"./Front End/FrontEnd\";\nimport CPU from \"./Work Logic/Processor/CPU\";\nimport Assembler from \"./Work Logic/Processor/Assembler\";\nimport \"./CSS/App.css\";\n\nclass App extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.cpu = new CPU();\n\t\tthis.a = new Assembler();\n\t}\n\n\t/**\n\t * Handles code editor updates.\n\t * Resets CPU and runs assembler to generate instruction que and labels.\n\t * @param {string} \teditor \t- User input instructions\n\t */\n\teditorUpdate = (editor) => {\n\t\tconsole.clear();\n\t\tconsole.log(\"Run Assembler\");\n\t\tif (this.a.run(editor)) {\n\t\t\tconsole.log(\"Assembler ran successfully\");\n\t\t\tthis.cpu.populate(this.a.bundles);\n\t\t}\n\t\tthis.forceUpdate();\n\t}\n\n\t/**\n\t * Step one instruction, if any left to execute\n\t * @field que : All instructions\n\t * @field queLength: Amount of instructions\n\t */\n\tstepBtn = () => {\n\t\tthis.cpu.step();\n\t\tthis.forceUpdate(); // To re-render\n\t}\n\n\t/**\n\t * Run button pressed. Runs remaining instructions.\n\t */\n\trunBtn = () => {\n\t\tthis.cpu.run();\n\t\tthis.forceUpdate(); // To re-render\n\t}\n\n\t/**\n\t * Reset button pressed. Resets program execution:\n\t * Sets pc = 0, resets mem and registers and goes to first bundle\n\t */\n\tresetBtn = () => {\n\t\tthis.cpu.populate(this.a.bundles);\n\t\tthis.forceUpdate(); // To re-render\n\t}\n\n\t/**\n\t * Prev button pressed. Reverts the execution of the last bundle executed.\n\t */\n\tprevBtn = () => {\n\t\tthis.cpu.prev();\n\t\tthis.forceUpdate(); // To re-render\n\t}\n\n\t/**\n\t * Dump button pressed. Saves the binary stream to a file.\n\t */\n\tdumpBtn = () => {\n\t\tlet mem = this.cpu.getMem();\n\t\tlet dump = new Uint8Array(mem[\"TEXT_END\"]);\n\t\t\n\t\tfor (let i = 0; i < mem[\"TEXT_END\"]; i += 4) {\n\t\t\tdump[i] = mem[i];\n\t\t\tdump[i+1] = mem[i+1];\n\t\t\tdump[i+2] = mem[i+2];\n\t\t\tdump[i+3] = mem[i+3];\t\n\t\t}\n\n\t\tlet file = new Blob([dump], {type: \"application/octet-stream\"});\n\t\tlet a = document.createElement(\"a\"), url = URL.createObjectURL(file);\n\t\ta.href = url;\n\t\ta.download = \"chora.o\";\n\t\tdocument.body.appendChild(a);\n\t\ta.click();\n\t\tsetTimeout(function() {\n\t\t\tdocument.body.removeChild(a);\n\t\t\twindow.URL.revokeObjectURL(url);  \n\t\t}, 0); \n\t\t\n\t}\n\n\trender() {\n\t\tdocument.body.style.overflowY = \"hidden\";\n\t\treturn (\n\t\t\t<div className=\"no-scroll\">\n\t\t\t\t<FrontEnd\n\t\t\t\t\tregisters={this.cpu.getReg()}\n\t\t\t\t\tmemory={this.cpu.getMem()}\n\t\t\t\t\thistory={this.cpu.state.history}\n\t\t\t\t\teditorUpdate={this.editorUpdate}\n\t\t\t\t\tstepClick={this.stepBtn}\n\t\t\t\t\trunClick={this.runBtn}\n\t\t\t\t\tprevClick={this.prevBtn}\n\t\t\t\t\tresetClick={this.resetBtn}\n\t\t\t\t\tdumpClick = {this.dumpBtn}\n\t\t\t\t\tpc={this.cpu.getPC()}\n\t\t\t\t\tbundles={this.cpu.bundles}\n\t\t\t\t\terror={this.a.error}\n\t\t\t\t\tnumMap={this.a.numMap}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\"; \n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}